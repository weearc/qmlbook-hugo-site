<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="动画（Animations） #  动画被用于属性的改变。一个动画定义了属性值改变的曲线，将一个属性值变化从一个值过渡到另一个值。动画是由一连串的目标属性活动定义的，平缓的曲线算法能够引发一个定义时间内属性的持续变化。所有在QtQuick中的动画都由同一个计时器来控制，因此它们始终都保持同步，这也提高了动画的性能和显示效果。
注意
动画控制了属性的改变，也就是值的插入。这是一个基本的概念，QML是基于元素，属性与脚本的。每一个元素都提供了许多的属性，每一个属性都在等待使用动画。在这本书中你将会看到这是一个壮阔的场景，你会发现你自己在看一些动画时欣赏它们的美丽并且肯定自己的创造性想法。然后请记住：动画控制了属性的改变，每个元素都有大量的属性供你任意使用。
 // animation.qml import QtQuick 2.0 Image { source: &#34;assets/background.png&#34; Image { x: 40; y: 80 source: &#34;assets/rocket.png&#34; NumberAnimation on x { to: 240 duration: 4000 loops: Animation.Infinite } RotationAnimation on rotation { to: 360 duration: 4000 loops: Animation.Infinite } } } 上面这个例子在x坐标和旋转属性上应用了一个简单的动画。每一次动画持续4000毫秒并且永久循环。x轴坐标动画展示了火箭的x坐标逐渐移至240，旋转动画展示了当前角度到360度的旋转。两个动画同时运行，并且在加载用户界面完成后开始。
现在你可以通过to属性和duration属性来实现动画效果。或者你可以在opacity或者scale上添加动画作为例子，集成这两个参数，你可以实现火箭逐渐消失在太空中，试试吧!
5.1.1 动画元素（Animation Elements） #  有几种类型的动画，每一种都在特定情况下都有最佳的效果，下面列出了一些常用的动画：
  PropertyAnimation（属性动画）- 使用属性值改变播放的动画
  NumberAnimation（数字动画）- 使用数字改变播放的动画
  ColorAnimation（颜色动画）- 使用颜色改变播放的动画
  RotationAnimation（旋转动画）- 使用旋转改变播放的动画">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="动画（Animations） #  动画被用于属性的改变。一个动画定义了属性值改变的曲线，将一个属性值变化从一个值过渡到另一个值。动画是由一连串的目标属性活动定义的，平缓的曲线算法能够引发一个定义时间内属性的持续变化。所有在QtQuick中的动画都由同一个计时器来控制，因此它们始终都保持同步，这也提高了动画的性能和显示效果。
注意
动画控制了属性的改变，也就是值的插入。这是一个基本的概念，QML是基于元素，属性与脚本的。每一个元素都提供了许多的属性，每一个属性都在等待使用动画。在这本书中你将会看到这是一个壮阔的场景，你会发现你自己在看一些动画时欣赏它们的美丽并且肯定自己的创造性想法。然后请记住：动画控制了属性的改变，每个元素都有大量的属性供你任意使用。
 // animation.qml import QtQuick 2.0 Image { source: &#34;assets/background.png&#34; Image { x: 40; y: 80 source: &#34;assets/rocket.png&#34; NumberAnimation on x { to: 240 duration: 4000 loops: Animation.Infinite } RotationAnimation on rotation { to: 360 duration: 4000 loops: Animation.Infinite } } } 上面这个例子在x坐标和旋转属性上应用了一个简单的动画。每一次动画持续4000毫秒并且永久循环。x轴坐标动画展示了火箭的x坐标逐渐移至240，旋转动画展示了当前角度到360度的旋转。两个动画同时运行，并且在加载用户界面完成后开始。
现在你可以通过to属性和duration属性来实现动画效果。或者你可以在opacity或者scale上添加动画作为例子，集成这两个参数，你可以实现火箭逐渐消失在太空中，试试吧!
5.1.1 动画元素（Animation Elements） #  有几种类型的动画，每一种都在特定情况下都有最佳的效果，下面列出了一些常用的动画：
  PropertyAnimation（属性动画）- 使用属性值改变播放的动画
  NumberAnimation（数字动画）- 使用数字改变播放的动画
  ColorAnimation（颜色动画）- 使用颜色改变播放的动画
  RotationAnimation（旋转动画）- 使用旋转改变播放的动画" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mirrors.cqu.edu.cn/qmlbook/fluid_elements/animations/" /><meta property="article:section" content="fluid_elements" />



<title>Animations | Qml Book</title>
<link rel="manifest" href="/qmlbook/manifest.json">
<link rel="icon" href="/qmlbook/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/qmlbook/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css" integrity="sha256-l8/aT148n6SaK/jUAfTdwO7Fdsmc3PavvsGRcyAMN9s=" crossorigin="anonymous">
  <script defer src="/qmlbook/flexsearch.min.js"></script>
  <script defer src="/qmlbook/en.search.min.7eaa324ae4aad96718321da9bf7ce2963bf997813e848e1e16bcc0e89048af9b.js" integrity="sha256-fqoySuSq2WcYMh2pv3ziljv5l4E&#43;hI4eFrzA6JBIr5s=" crossorigin="anonymous"></script>

  <script defer src="/qmlbook/sw.min.c5fd65d1492edd0e92acb72a8983e44a68ad14c15883246783ed1d96f25e6858.js" integrity="sha256-xf1l0Uku3Q6SrLcqiYPkSmitFMFYgyRng&#43;0dlvJeaFg=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/qmlbook/"><span>Qml Book</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <h1 id="summary">
  Summary
  <a class="anchor" href="#summary">#</a>
</h1>
<ul>
<li>
  <a href="/qmlbook/README/">Introduction</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/README/">Qt5概述</a>
<ul>
<li>
  <a href="/qmlbook/meet_qt_5/preface/">序</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt5_introduction/">Qt5介绍</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt_building_blocks/">Qt构建模块（Qt Building Blocks）</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt_project/">Qt项目（Qt Project）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/get_start/README/">开始学习（Get Start）</a>
<ul>
<li>
  <a href="/qmlbook/get_start/qt5installing_qt_5_sdk/">安装Qt5软件工具包（Installing Qt 5 SDK）</a></li>
<li>
  <a href="/qmlbook/get_start/hello_world/">你好世界（Hello World）</a></li>
<li>
  <a href="/qmlbook/get_start/application_types/">应用程序类型（Application Types）</a></li>
<li>
  <a href="/qmlbook/get_start/summary/">总结（ Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_creator_ide/README/">Qt Creator集成开发环境（Qt Creator IDE）</a>
<ul>
<li>
  <a href="/qmlbook/qt_creator_ide/the_user_interface/">用户界面（The User Interface）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/qtregistering_your_qt_kit/">注册你的Qt工具箱（Registering your Qt Kit）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/managing_projects/">项目管理（Managing Projects）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/using_the_editor/">使用编辑器（Using the Editor）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/locator/">定位器（Locator）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/debugging/">调试（Debugging）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/shortcuts/">快捷键（Shortcuts）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/quick_starter/README/">QML快速入门（Quick Starter）</a>
<ul>
<li>
  <a href="/qmlbook/quick_starter/qmlqml_syntax/">QML语法（QML Syntax）</a></li>
<li>
  <a href="/qmlbook/quick_starter/basic_elements/">基本元素（Basic Elements）</a></li>
<li>
  <a href="/qmlbook/quick_starter/compontents/">组件（Compontents）</a></li>
<li>
  <a href="/qmlbook/quick_starter/simple_transformations/">简单的转换（Simple Transformations）</a></li>
<li>
  <a href="/qmlbook/quick_starter/positioning_element/">定位元素（Positioning Element）</a></li>
<li>
  <a href="/qmlbook/quick_starter/layout_items/">布局元素（Layout Items）</a></li>
<li>
  <a href="/qmlbook/quick_starter/input_element/">输入元素（Input Element）</a></li>
<li>
  <a href="/qmlbook/quick_starter/advanced_techniques/"> 高级用法（Advanced Techniques）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/fluid_elements/README/">动态元素（Fluid Elements）</a>
<ul>
<li>
  <a href="/qmlbook/fluid_elements/animations/"class=active>动画（Animations）</a></li>
<li>
  <a href="/qmlbook/fluid_elements/states_and_transitions/">状态与过渡（States and Transitions）</a></li>
<li>
  <a href="/qmlbook/fluid_elements/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/model-view-delegate/README/">模型-视图-代理（Model-View-Delegate）</a>
<ul>
<li>
  <a href="/qmlbook/model-view-delegate/concept/">概念（Concept）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/basic_model/">基础模型（Basic Model）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/dynamic_views/">动态视图（Dynamic Views）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/delegate/">代理（Delegate）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/canvas_element/README/">画布元素（Canvas Element）</a>
<ul>
<li>
  <a href="/qmlbook/canvas_element/convenient_api/">便捷的接口（Convenient API）</a></li>
<li>
  <a href="/qmlbook/canvas_element/gradients/">渐变（Gradients）</a></li>
<li>
  <a href="/qmlbook/canvas_element/shadows/">阴影（Shadows）</a></li>
<li>
  <a href="/qmlbook/canvas_element/images/">图片（Images）</a></li>
<li>
  <a href="/qmlbook/canvas_element/transformation/">转换（Transformation）</a></li>
<li>
  <a href="/qmlbook/canvas_element/composition_mode/">组合模式（Composition Mode）</a></li>
<li>
  <a href="/qmlbook/canvas_element/pixels_buffer/">像素缓冲（Pixels Buffer）</a></li>
<li>
  <a href="/qmlbook/canvas_element/canvas_paint/">画布绘制（Canvas Paint）</a></li>
<li>
  <a href="/qmlbook/canvas_element/html5porting_from_html5_canvas/">HTML5画布移植（Porting from HTML5 Canvas）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/particle_simulations/README/">粒子模拟（Particle Simulations）</a>
<ul>
<li>
  <a href="/qmlbook/particle_simulations/concept/">概念（Concept）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/simple_simulation/">简单的模拟（Simple Simulation）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_parameters/">粒子参数（Particle Parameters）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/directed_particle/">粒子方向（Directed Particle）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_painter/">粒子画笔（Particle Painter）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/affecting_particles/">粒子控制（Affecting Particles）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_group/">粒子组（Particle Group）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/shader_effect/README/">着色器效果（Shader Effect）</a>
<ul>
<li>
  <a href="/qmlbook/shader_effect/openglopengl_shader/">OpenGL着色器（OpenGL Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/shader_elements/">着色器元素（Shader Elements）</a></li>
<li>
  <a href="/qmlbook/shader_effect/fragement_shader/">片段着色器（Fragement Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/wave_effect/">波浪效果（Wave Effect）</a></li>
<li>
  <a href="/qmlbook/shader_effect/vertex_shader/">顶点着色器（Vertex Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/curtain_effect/">剧幕效果（Curtain Effect）</a></li>
<li>
  <a href="/qmlbook/shader_effect/qtqt_graphicseffect_library/">Qt图像效果库（Qt GraphicsEffect Library）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/multimedia/README/">多媒体（Multimedia）</a>
<ul>
<li>
  <a href="/qmlbook/multimedia/playing_media/">媒体播放（Playing Media）</a></li>
<li>
  <a href="/qmlbook/multimedia/sounds_effects/">声音效果（Sounds Effects）</a></li>
<li>
  <a href="/qmlbook/multimedia/video_streams/">视频流（Video Streams）</a></li>
<li>
  <a href="/qmlbook/multimedia/capturing_images/">捕捉图像（Capturing Images）</a></li>
<li>
  <a href="/qmlbook/multimedia/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
<li>
  <a href="/qmlbook/multimedia/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/networking/README/">网络（Networking）</a>
<ul>
<li>
  <a href="/qmlbook/networking/httpuiserving_ui_via_http/">通过HTTP服务用户界面（Serving UI via HTTP）</a></li>
<li>
  <a href="/qmlbook/networking/templating/">模板（Templating）</a></li>
<li>
  <a href="/qmlbook/networking/httphttp_requests/">HTTP请求（HTTP Requests）</a></li>
<li>
  <a href="/qmlbook/networking/local_files/">本地文件（Local files）</a></li>
<li>
  <a href="/qmlbook/networking/restrest_api/">REST接口（REST API）</a></li>
<li>
  <a href="/qmlbook/networking/authentication_using_oauth/">使用开放授权登陆验证（Authentication using OAuth）</a></li>
<li>
  <a href="/qmlbook/networking/engine_io/">云服务（Engine IO）</a></li>
<li>
  <a href="/qmlbook/networking/web_sockets/">Web Sockets</a></li>
<li>
  <a href="/qmlbook/networking/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/storage/README/">存储（Storage）</a>
<ul>
<li>
  <a href="/qmlbook/storage/settings/">配置（Settings）</a></li>
<li>
  <a href="/qmlbook/storage/local_storage_-_sql/">本地存储 - SQL（Local Storage - SQL）</a></li>
<li>
  <a href="/qmlbook/storage/other_storage_apis/">其它存储接口（Other Storage APIs）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/README/">动态QML（Dynamic QML）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/loading_components_dynamically/">动态加载组件（Loading Components Dynamically）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/connecting_indirectly/">间接连接（Connecting Indirectly）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/binding_indirectly/">间接绑定（Binding Indirectly）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/creating_and_destroying_objects/">创建与销毁对象（Creating and Destroying Objects）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/dynamically_loading_and_instantiating_items/">动态加载和实例化项（Dynamically Loading and Instantiating Items）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/dynamically_instantiating_items_from_text/">从文本中动态实例化项（Dynamically Instantiating Items from Text）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/managing_dynamically_created_elements/">管理动态创建的元素（Managing Dynamically Created Elements）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/tracking_dynamic_objects/">跟踪动态对象（Tracking Dynamic Objects）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/javascript/README/">JavaScript</a>
<ul>
<li>
  <a href="/qmlbook/javascript/browserhtml_vs_qtquickqml/">浏览器/HTML与QtQuick/QML对比（Browser/HTML vs QtQuick/QML）</a></li>
<li>
  <a href="/qmlbook/javascript/the_language/">JavaScript语法（The Language）</a></li>
<li>
  <a href="/qmlbook/javascript/js_objects/">JS对象（JS Objects）</a></li>
<li>
  <a href="/qmlbook/javascript/creating_a_js_console/">创建JS控制台（Creating a JS Console）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/README/">Qt and C++</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/a_boilerplate_application/">演示程序（A Boilerplate Application）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/the_qobject/">Qt对象（The QObject）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/build_systems/">编译系统（Build Systems）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/qmake/">QMake</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/cmake/">CMake</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/common_qt_classes/">Qt通用类（Common Qt Classes）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/qstring/">QString</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/sequential_containers/">顺序容器（Sequential Containers）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/associative_containers/">组合容器（Associative Containers）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/file_io/">文件IO（File IO）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/models_in_c&#43;&#43;/">C++数据模型（Models in C++）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/a_simple_model/">一个简单的模型（A simple model）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/more_complex_data/">更复杂的数据（More Complex Data）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/dynamic_data/">动态数据（Dynamic Data）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/advanced_techniques/">进阶技巧（Advanced Techniques）</a></li>
</ul>
</li>
</ul>
</li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/README/">C++扩展QML（Extending QML with C++）</a>
<ul>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/understanding_the_qml_run-time/">理解QML运行环境（Understanding the QML Run-time）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/plugin_content/">插件内容（Plugin Content）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/creating_the_plugin/">创建插件（Creating the plugin）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/fileio_implementation/">FileIO实现（FileIO Implementation）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/using_fileio/">使用FileIO（Using FileIO）</a>
<ul>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/the_application_window/">应用程序窗口（The Application Window）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/using_actions/">使用动作（Using Actions）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/formatting_the_table/">格式化表格（Formatting the Table）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/reading_data/">读取数据（Reading Data）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/writing_data/">写入数据（Writing Data）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/finishing_touch/">收尾工作（Finishing Touch）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/other/README/">其它（Other）</a>
<ul>
<li>
  <a href="/qmlbook/other/assets/">示例源码</a></li>
<li>
  <a href="/qmlbook/other/enginsh_to_chinses/">术语英汉对照表</a></li>
<li>
  <a href="/qmlbook/other/book_format/">格式定义</a></li>
<li>
  <a href="/qmlbook/other/collaboration_correction/">协作校正</a></li>
</ul>
</li>
</ul>






  
<ul>
  
  <li>
    <a href="https://github.com/cwc1987/QmlBook-In-Chinese" target="_blank" rel="noopener">
        QmlBook In Chinese
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/qmlbook/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Animations</strong>

  <label for="toc-control">
    
    <img src="/qmlbook/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#动画animations">动画（Animations）</a>
      <ul>
        <li><a href="#511-动画元素animation-elements">5.1.1 动画元素（Animation Elements）</a></li>
        <li><a href="#512-应用动画applying-animations">5.1.2 应用动画（Applying Animations）</a></li>
        <li><a href="#513-缓冲曲线easing-curves">5.1.3 缓冲曲线（Easing Curves）</a></li>
        <li><a href="#514-动画分组grouped-animations">5.1.4 动画分组（Grouped Animations）</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="动画animations">
  动画（Animations）
  <a class="anchor" href="#%e5%8a%a8%e7%94%bbanimations">#</a>
</h1>
<p>动画被用于属性的改变。一个动画定义了属性值改变的曲线，将一个属性值变化从一个值过渡到另一个值。动画是由一连串的目标属性活动定义的，平缓的曲线算法能够引发一个定义时间内属性的持续变化。所有在QtQuick中的动画都由同一个计时器来控制，因此它们始终都保持同步，这也提高了动画的性能和显示效果。</p>
<p><strong>注意</strong></p>
<p><strong>动画控制了属性的改变，也就是值的插入。这是一个基本的概念，QML是基于元素，属性与脚本的。每一个元素都提供了许多的属性，每一个属性都在等待使用动画。在这本书中你将会看到这是一个壮阔的场景，你会发现你自己在看一些动画时欣赏它们的美丽并且肯定自己的创造性想法。然后请记住：动画控制了属性的改变，每个元素都有大量的属性供你任意使用。</strong></p>
<p>
  <img src="http://qmlbook.org/_images/animation.png" alt="" /></p>
<pre tabindex="0"><code>// animation.qml

import QtQuick 2.0

Image {
    source: &#34;assets/background.png&#34;

    Image {
        x: 40; y: 80
        source: &#34;assets/rocket.png&#34;

        NumberAnimation on x {
            to: 240
            duration: 4000
            loops: Animation.Infinite
        }
        RotationAnimation on rotation {
            to: 360
            duration: 4000
            loops: Animation.Infinite
        }
    }
}
</code></pre><p>上面这个例子在x坐标和旋转属性上应用了一个简单的动画。每一次动画持续4000毫秒并且永久循环。x轴坐标动画展示了火箭的x坐标逐渐移至240，旋转动画展示了当前角度到360度的旋转。两个动画同时运行，并且在加载用户界面完成后开始。</p>
<p>现在你可以通过to属性和duration属性来实现动画效果。或者你可以在opacity或者scale上添加动画作为例子，集成这两个参数，你可以实现火箭逐渐消失在太空中，试试吧!</p>
<h2 id="511-动画元素animation-elements">
  5.1.1 动画元素（Animation Elements）
  <a class="anchor" href="#511-%e5%8a%a8%e7%94%bb%e5%85%83%e7%b4%a0animation-elements">#</a>
</h2>
<p>有几种类型的动画，每一种都在特定情况下都有最佳的效果，下面列出了一些常用的动画：</p>
<ul>
<li>
<p>PropertyAnimation（属性动画）- 使用属性值改变播放的动画</p>
</li>
<li>
<p>NumberAnimation（数字动画）- 使用数字改变播放的动画</p>
</li>
<li>
<p>ColorAnimation（颜色动画）- 使用颜色改变播放的动画</p>
</li>
<li>
<p>RotationAnimation（旋转动画）- 使用旋转改变播放的动画</p>
</li>
</ul>
<p>除了上面这些基本和通常使用的动画元素，QtQuick还提供了一切特殊场景下使用的动画：</p>
<ul>
<li>
<p>PauseAnimation（停止动画）- 运行暂停一个动画</p>
</li>
<li>
<p>SequentialAnimation（顺序动画）- 允许动画有序播放</p>
</li>
<li>
<p>ParallelAnimation（并行动画）- 允许动画同时播放</p>
</li>
<li>
<p>AnchorAnimation（锚定动画）- 使用锚定改变播放的动画</p>
</li>
<li>
<p>ParentAnimation（父元素动画）- 使用父对象改变播放的动画</p>
</li>
<li>
<p>SmotthedAnimation（平滑动画）- 跟踪一个平滑值播放的动画</p>
</li>
<li>
<p>SpringAnimation（弹簧动画）- 跟踪一个弹簧变换的值播放的动画</p>
</li>
<li>
<p>PathAnimation（路径动画）- 跟踪一个元素对象的路径的动画</p>
</li>
<li>
<p>Vector3dAnimation（3D容器动画）- 使用QVector3d值改变播放的动画</p>
</li>
</ul>
<p>我们将在后面学习怎样创建一连串的动画。当使用更加复杂的动画时，我们可能需要在播放一个动画时中改变一个属性或者运行一个脚本。对于这个问题，QtQuick提供了一个动作元素：</p>
<ul>
<li>
<p>PropertyAction（属性动作）- 在播放动画时改变属性</p>
</li>
<li>
<p>ScriptAction（脚本动作）- 在播放动画时运行脚本</p>
</li>
</ul>
<p>在这一章中我们将会使用一些小的例子来讨论大多数类型的动画。</p>
<h2 id="512-应用动画applying-animations">
  5.1.2 应用动画（Applying Animations）
  <a class="anchor" href="#512-%e5%ba%94%e7%94%a8%e5%8a%a8%e7%94%bbapplying-animations">#</a>
</h2>
<p>动画可以通过以下几种方式来应用：</p>
<ul>
<li>
<p>属性动画 - 在元素完整加载后自动运行</p>
</li>
<li>
<p>属性动作 - 当属性值改变时自动运行</p>
</li>
<li>
<p>独立运行动画 - 使用start()函数明确指定运行或者running属性被设置为true（比如通过属性绑定）</p>
</li>
</ul>
<p>后面我们会谈论如何在状态变换时播放动画。</p>
<p><strong>扩展可点击图像元素版本2（ClickableImage Version2）</strong></p>
<p>为了演示动画的使用方法，我们重新实现了ClickableImage组件并且使用了一个文本元素（Text Element）来扩展它。</p>
<pre tabindex="0"><code>// ClickableImageV2.qml
// Simple image which can be clicked

import QtQuick 2.0

Item {
    id: root
    width: container.childrenRect.width
    height: container.childrenRect.height
    property alias text: label.text
    property alias source: image.source
    signal clicked

    Column {
        id: container
        Image {
            id: image
        }
        Text {
            id: label
            width: image.width
            horizontalAlignment: Text.AlignHCenter
            wrapMode: Text.WordWrap
            color: &#34;#111111&#34;
        }
    }

    MouseArea {
        anchors.fill: parent
        onClicked: root.clicked()
    }
}
</code></pre><p>为了给图片下面的元素定位，我们使用了Column（列）定位器，并且使用基于列的子矩形（childRect）属性来计算它的宽度和高度（width and height）。我们导出了文本（text）和图形源（source）属性，一个点击信号（clicked signal）。我们使用文本元素的wrapMode属性来设置文本与图像一样宽并且可以自动换行。</p>
<p><strong>注意</strong></p>
<p><strong>由于几何依赖关系的反向（父几何对象依赖于子几何对象）我们不能对ClickableImageV2设置宽度/高度（width/height），因为这样将会破坏我们已经做好的属性绑定。这是我们内部设计的限制，作为一个设计组件的人你需要明白这一点。通常我们更喜欢内部几何图像依赖于父几何对象。</strong></p>
<p>
  <img src="http://qmlbook.org/_images/animationtypes_start.png" alt="" /></p>
<p>三个火箭位于相同的y轴坐标（y = 200）。它们都需要移动到y = 40。每一个火箭都使用了一种的方法来完成这个功能。</p>
<pre tabindex="0"><code>    ClickableImageV3 {
        id: rocket1
        x: 40; y: 200
        source: &#34;assets/rocket2.png&#34;
        text: &#34;animation on property&#34;
        NumberAnimation on y {
            to: 40; duration: 4000
        }
    }
</code></pre><p><strong>第一个火箭</strong></p>
<p>第一个火箭使用了Animation on <property>属性变化的策略来完成。动画会在加载完成后立即播放。点击火箭可以重置它回到开始的位置。在动画播放时重置第一个火箭不会有任何影响。在动画开始前的几分之一秒设置一个新的y轴坐标让人感觉挺不安全的，应当避免这样的属性值竞争的变化。</p>
<pre tabindex="0"><code>    ClickableImageV3 {
        id: rocket2
        x: 152; y: 200
        source: &#34;assets/rocket2.png&#34;
        text: &#34;behavior on property&#34;
        Behavior on y {
            NumberAnimation { duration: 4000 }
        }

        onClicked: y = 40
        // random y on each click
    //        onClicked: y = 40+Math.random()*(205-40)
    }
</code></pre><p><strong>第二个火箭</strong></p>
<p>第二个火箭使用了behavior on <property>属性行为策略的动画。这个行为告诉属性值每时每刻都在变化，通过动画的方式来改变这个值。可以使用行为元素的enabled : false来设置行为失效。当你点击这个火箭时它将会开始运行（y轴坐标逐渐移至40）。然后其它的点击对于位置的改变没有任何的影响。你可以试着使用一个随机值（例如 40+(Math.random()*(205-40)）来设置y轴坐标。你可以发现动画始终会将移动到新位置的时间匹配在4秒内完成。</p>
<pre tabindex="0"><code>    ClickableImageV3 {
        id: rocket3
        x: 264; y: 200
        source: &#34;assets/rocket2.png&#34;
        onClicked: anim.start()
    //        onClicked: anim.restart()

        text: &#34;standalone animation&#34;

        NumberAnimation {
            id: anim
            target: rocket3
            properties: &#34;y&#34;
            from: 205
            to: 40
            duration: 4000
        }
    }
</code></pre><p><strong>第三个火箭</strong></p>
<p>第三个火箭使用standalone animation独立动画策略。这个动画由一个私有的元素定义并且可以写在文档的任何地方。点击火箭调用动画函数start()来启动动画。每一个动画都有start()，stop()，resume()，restart()函数。这个动画自身可以比其他类型的动画更早的获取到更多的相关信息。我们只需要定义目标和目标元素的属性需要怎样改变的一个动画。我们定义一个to属性的值，在这个例子中我们也定义了一个from属性的值允许动画可以重复运行。</p>
<p>
  <img src="http://qmlbook.org/_images/animationtypes.png" alt="" /></p>
<p>点击背景能够重新设置所有的火箭回到它们的初始位置。第一个火箭无法被重置，只有重启程序重新加载元素才能重置它。</p>
<p><strong>注意</strong></p>
<p><strong>另一个启动/停止一个动画的方法是绑定一个动画的running属性。当需要用户输入控制属性时这种方法非常有用：</strong></p>
<pre tabindex="0"><code>    NumberAnimation {
        ...
        // animation runs when mouse is pressed
        running: area.pressed
    }
    MouseArea {
        id: area
    }
</code></pre><h2 id="513-缓冲曲线easing-curves">
  5.1.3 缓冲曲线（Easing Curves）
  <a class="anchor" href="#513-%e7%bc%93%e5%86%b2%e6%9b%b2%e7%ba%bfeasing-curves">#</a>
</h2>
<p>属性值的改变能够通过一个动画来控制，缓冲曲线属性影响了一个属性值改变的插值算法。我们现在已经定义的动画都使用了一种线性的插值算法，因为一个动画的默认缓冲类型是Easing.Linear。在一个小场景下的x轴与y轴坐标改变可以得到最好的视觉效果。一个线性插值算法将会在动画开始时使用from的值到动画结束时使用的to值绘制一条直线，所以缓冲类型定义了曲线的变化情况。精心为一个移动的对象挑选一个合适的缓冲类型将会使界面更加自然，例如一个页面的滑出，最初使用缓慢的速度滑出，然后在最后滑出时使用高速滑出，类似翻书一样的效果。</p>
<p><strong>注意</strong></p>
<p><strong>不要过度的使用动画。用户界面动画的设计应该尽量小心，动画是让界面更加生动而不是充满整个界面。眼睛对于移动的东西非常敏感，很容易干扰用户的使用。</strong></p>
<p>在下面的例子中我们将会使用不同的缓冲曲线，每一种缓冲曲线都都使用了一个可点击图片来展示，点击将会在动画中设置一个新的缓冲类型并且使用这种曲线重新启动动画。</p>
<p>
  <img src="http://qmlbook.org/_images/easingtypes.png" alt="" /></p>
<p><strong>扩展可点击图像V3（ClickableImage V3）</strong></p>
<p>我们给图片和文本添加了一个小的外框来增强我们的ClickableImage。添加一个属性property bool framed: false来作为我们的API，基于framed的值我们能够设置这个框是否可见，并且不破坏之前用户的使用。下面是我们做的修改。</p>
<pre tabindex="0"><code>// ClickableImageV2.qml
// Simple image which can be clicked

import QtQuick 2.0

Item {
    id: root
    width: container.childrenRect.width + 16
    height: container.childrenRect.height + 16
    property alias text: label.text
    property alias source: image.source
    signal clicked

    // M1&gt;&gt;
    // ... add a framed rectangle as container
    property bool framed : false

    Rectangle {
        anchors.fill: parent
        color: &#34;white&#34;
        visible: root.framed
    }
</code></pre><p>这个例子的代码非常简洁。我们使用了一连串的缓冲曲线的名称（property variant easings）并且在一个Repeater（重复元素）中将它们分配给一个ClickableImage。图片的源路径通过一个命名方案来定义，一个叫做“InQuad”的缓冲曲线在“curves/InQuad.png”中有一个对应的图片。如果你点击一个曲线图，这个点击将会分配一个缓冲类型给动画然后重新启动动画。动画自身是用来设置方块的x坐标属性在2秒内变化的独立动画。</p>
<pre tabindex="0"><code>// easingtypes.qml

import QtQuick 2.0

DarkSquare {
    id: root
    width: 600
    height: 340

    // A list of easing types
    property variant easings : [
        &#34;Linear&#34;, &#34;InQuad&#34;, &#34;OutQuad&#34;, &#34;InOutQuad&#34;,
        &#34;InCubic&#34;, &#34;InSine&#34;, &#34;InCirc&#34;, &#34;InElastic&#34;,
        &#34;InBack&#34;, &#34;InBounce&#34; ]


    Grid {
        id: container
        anchors.top: parent.top
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.margins: 16
        height: 200
        columns: 5
        spacing: 16
        // iterates over the &#39;easings&#39; list
        Repeater {
            model: easings
            ClickableImageV3 {
                framed: true
                // the current data entry from &#39;easings&#39; list
                text: modelData
                source: &#34;curves/&#34; + modelData + &#34;.png&#34;
                onClicked: {
                    // set the easing type on the animation
                    anim.easing.type = modelData
                    // restart the animation
                    anim.restart()
                }
            }
        }
    }

    // The square to be animated
    GreenSquare {
        id: square
        x: 40; y: 260
    }

    // The animation to test the easing types
    NumberAnimation {
        id: anim
        target: square
        from: 40; to: root.width - 40 - square.width
        properties: &#34;x&#34;
        duration: 2000
    }
}
</code></pre><p>当你运行这个例子时，请注意观察动画的改变速度。一些动画对于这个对象看起来很自然，一些看起来非常恼火。</p>
<p>除了duration属性与easing.type属性，你也可以对动画进行微调。例如PropertyAnimation属性，大多数动画都支持附加的easing.amplitude（缓冲振幅），easing.overshoot（缓冲溢出），easing.period（缓冲周期），这些属性允许你对个别的缓冲曲线进行微调。不是所有的缓冲曲线都支持这些参数。可以查看Qt PropertyAnimation文档中的缓冲列表（easing table）来查看一个缓冲曲线的相关参数。</p>
<p><strong>注意</strong></p>
<p><strong>对于用户界面正确的动画非常重要。请记住动画是帮助用户界面更加生动而不是刺激用户的眼睛。</strong></p>
<h2 id="514-动画分组grouped-animations">
  5.1.4 动画分组（Grouped Animations）
  <a class="anchor" href="#514-%e5%8a%a8%e7%94%bb%e5%88%86%e7%bb%84grouped-animations">#</a>
</h2>
<p>通常使用的动画比一个属性的动画更加复杂。例如你想同时运行几个动画并把他们连接起来，或者在一个一个的运行，或者在两个动画之间执行一个脚本。动画分组提供了很好的帮助，作为命名建议可以叫做一组动画。有两种方法来分组：平行与连续。你可以使用SequentialAnimation（连续动画）和ParallelAnimation（平行动画）来实现它们，它们作为动画的容器来包含其它的动画元素。</p>
<p>
  <img src="http://qmlbook.org/_images/groupedanimation.png" alt="" /></p>
<p>当开始时，平行元素的所有子动画都会平行运行，它允许你在同一时间使用不同的属性来播放动画。</p>
<pre tabindex="0"><code>// parallelanimation.qml
import QtQuick 2.0

BrightSquare {
    id: root
    width: 300
    height: 200
    property int duration: 3000

    ClickableImageV3 {
        id: rocket
        x: 20; y: 120
        source: &#34;assets/rocket2.png&#34;
        onClicked: anim.restart()
    }

    ParallelAnimation {
        id: anim
        NumberAnimation {
            target: rocket
            properties: &#34;y&#34;
            to: 20
            duration: root.duration
        }
        NumberAnimation {
            target: rocket
            properties: &#34;x&#34;
            to: 160
            duration: root.duration
        }
    }
}
</code></pre><p>
  <img src="http://qmlbook.org/_images/parallelanimation_sequence.png" alt="" /></p>
<p>一个连续的动画将会一个一个的运行子动画。</p>
<pre tabindex="0"><code>// sequentialanimation.qml
import QtQuick 2.0

BrightSquare {
    id: root
    width: 300
    height: 200
    property int duration: 3000

    ClickableImageV3 {
        id: rocket
        x: 20; y: 120
        source: &#34;assets/rocket2.png&#34;
        onClicked: anim.restart()
    }

    SequentialAnimation {
        id: anim
        NumberAnimation {
            target: rocket
            properties: &#34;y&#34;
            to: 20
            // 60% of time to travel up
            duration: root.duration*0.6
        }
        NumberAnimation {
            target: rocket
            properties: &#34;x&#34;
            to: 160
            // 40% of time to travel sideways
            duration: root.duration*0.4
        }
    }
}
</code></pre><p>
  <img src="http://qmlbook.org/_images/sequentialanimation_sequence.png" alt="" /></p>
<p>分组动画也可以被嵌套，例如一个连续动画可以拥有两个平行动画作为子动画。我们来看看这个足球的例子。这个动画描述了一个从左向右扔一个球的行为：</p>
<p>
  <img src="http://qmlbook.org/_images/soccer_init.png" alt="" /></p>
<p>要弄明白这个动画我们需要剖析这个目标的运动过程。我们需要记住这个动画是通过属性变化来实现的动画，下面是不同部分的转换：</p>
<ul>
<li>
<p>从左向右的x坐标转换（X1）。</p>
</li>
<li>
<p>从下往上的y坐标转换（Y1）然后跟着一个从上往下的Y坐标转换（Y2）。</p>
</li>
<li>
<p>整个动画过程中360度旋转。</p>
</li>
</ul>
<p>这个动画将会花掉3秒钟的时间。</p>
<p>
  <img src="http://qmlbook.org/_images/soccer_plan.png" alt="" /></p>
<p>我们使用一个空的基本元素对象（Item）作为根元素，它的宽度为480，高度为300。</p>
<pre tabindex="0"><code>import QtQuick 1.1

Item {
    id: root
    width: 480
    height: 300
    property int duration: 3000

    ...
}
</code></pre><p>我们定义动画的总持续时间作为参考，以便更好的同步各部分的动画。</p>
<p>下一步我们需需要添加一个背景，在我们这个例子中有两个矩形框分别使用了绿色渐变和蓝色渐变填充。</p>
<pre tabindex="0"><code>    Rectangle {
        id: sky
        width: parent.width
        height: 200
        gradient: Gradient {
            GradientStop { position: 0.0; color: &#34;#0080FF&#34; }
            GradientStop { position: 1.0; color: &#34;#66CCFF&#34; }
        }
    }
    Rectangle {
        id: ground
        anchors.top: sky.bottom
        anchors.bottom: root.bottom
        width: parent.width
        gradient: Gradient {
            GradientStop { position: 0.0; color: &#34;#00FF00&#34; }
            GradientStop { position: 1.0; color: &#34;#00803F&#34; }
        }
    }
</code></pre><p>
  <img src="http://qmlbook.org/_images/soccer_stage1.png" alt="" /></p>
<p>上面部分的蓝色区域高度为200像素，下面部分的区域使用上面的蓝色区域的底作为锚定的顶，使用根元素的底作为底。</p>
<p>让我们将足球加入到屏幕上，足球是一个图片，位于路径“assets/soccer_ball.png”。首先我们需要将它放置在左下角接近边界处。</p>
<pre tabindex="0"><code>    Image {
        id: ball
        x: 20; y: 240
        source: &#34;assets/soccer_ball.png&#34;

        MouseArea {
            anchors.fill: parent
            onClicked: {
                ball.x = 20; ball.y = 240
                anim.restart()
            }
        }
    }
</code></pre><p>
  <img src="http://qmlbook.org/_images/soccer_stage2.png" alt="" /></p>
<p>图片与鼠标区域连接，点击球将会重置球的状态，并且动画重新开始。</p>
<p>首先使用一个连续的动画来播放两次的y轴变换。</p>
<pre tabindex="0"><code>    SequentialAnimation {
        id: anim
        NumberAnimation {
            target: ball
            properties: &#34;y&#34;
            to: 20
            duration: root.duration * 0.4
        }
        NumberAnimation {
            target: ball
            properties: &#34;y&#34;
            to: 240
            duration: root.duration * 0.6
        }
    }
</code></pre><p>
  <img src="http://qmlbook.org/_images/soccer_stage3.png" alt="" /></p>
<p>在动画总时间的40%的时间里完成上升部分，在动画总时间的60%的时间里完成下降部分，一个动画完成后播放下一个动画。目前还没有使用任何缓冲曲线。缓冲曲线将在后面使用easing curves来添加，现在我们只关心如何使用动画来完成过渡。</p>
<p>现在我们需要添加x轴坐标转换。x轴坐标转换需要与y轴坐标转换同时进行，所以我们需要将y轴坐标转换的连续动画和x轴坐标转换一起压缩进一个平行动画中。</p>
<pre tabindex="0"><code>    ParallelAnimation {
        id: anim
        SequentialAnimation {
            // ... our Y1, Y2 animation
        }
        NumberAnimation { // X1 animation
            target: ball
            properties: &#34;x&#34;
            to: 400
            duration: root.duration
        }
    }
</code></pre><p>
  <img src="http://qmlbook.org/_images/soccer_stage4.png" alt="" /></p>
<p>最后我们想要旋转这个球，我们需要向平行动画中添加一个新的动画，我们选择RotationAnimation来实现旋转。</p>
<pre tabindex="0"><code>    ParallelAnimation {
        id: anim
        SequentialAnimation {
            // ... our Y1, Y2 animation
        }
        NumberAnimation { // X1 animation
            // X1 animation
        }
        RotationAnimation {
            target: ball
            properties: &#34;rotation&#34;
            to: 720
            duration: root.duration
        }
    }
</code></pre><p>我们已经完成了整个动画链表，然后我们需要给动画提供一个正确的缓冲曲线来描述一个移动的球。对于Y1动画我们使用Easing.OutCirc缓冲曲线，它看起来更像是一个圆周运动。Y2使用了Easing.OutBounce缓冲曲线，因为在最后球会发生反弹。（试试使用Easing.InBounce，你会发现反弹将会立刻开始。）。X1和ROT1动画都使用线性曲线。</p>
<p>下面是这个动画最后的代码，提供给你作为参考：</p>
<pre tabindex="0"><code>    ParallelAnimation {
        id: anim
        SequentialAnimation {
            NumberAnimation {
                target: ball
                properties: &#34;y&#34;
                to: 20
                duration: root.duration * 0.4
                easing.type: Easing.OutCirc
            }
            NumberAnimation {
                target: ball
                properties: &#34;y&#34;
                to: 240
                duration: root.duration * 0.6
                easing.type: Easing.OutBounce
            }
        }
        NumberAnimation {
            target: ball
            properties: &#34;x&#34;
            to: 400
            duration: root.duration
        }
        RotationAnimation {
            target: ball
            properties: &#34;rotation&#34;
            to: 720
            duration: root.duration * 1.1
        }
    }
</code></pre></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#动画animations">动画（Animations）</a>
      <ul>
        <li><a href="#511-动画元素animation-elements">5.1.1 动画元素（Animation Elements）</a></li>
        <li><a href="#512-应用动画applying-animations">5.1.2 应用动画（Applying Animations）</a></li>
        <li><a href="#513-缓冲曲线easing-curves">5.1.3 缓冲曲线（Easing Curves）</a></li>
        <li><a href="#514-动画分组grouped-animations">5.1.4 动画分组（Grouped Animations）</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












