<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="应用程序类型（Application Types） #  这一节贯穿了可能使用Qt5编写的不同类型的应用程序。没有任何建议的选择，只是想告诉读者Qt5通常情况下能做些什么。
2.3.1 控制台应用程序 #  一个控制台应用程序不需要提供任何人机交互图形界面通常被称作系统服务，或者通过命令行来运行。Qt5附带了一系列现成的组件来帮助你非常有效的创建跨平台的控制台应用程序。例如网络应用程序编程接口或者文件应用程序编程接口，字符串的处理，自Qt5.1发布的高效的命令解析器。由于Qt是基于C&#43;&#43;的高级应用程序接口，你能够快速的编程并且程序拥有快速的执行速度。不要认为Qt仅仅只是用户界面工具，它也提供了许多其它的功能。
字符串处理
在第一个例子中我们展示了怎样简单的增加两个字符串常量。这不是一个有用的应用程序，但能让你了解本地端C&#43;&#43;应用程序没有事件循环时是什么样的。
// module or class includes #include &lt;QtCore&gt; // text stream is text-codec aware QTextStream cout(stdout, QIODevice::WriteOnly); int main(int argc, char** argv) { // avoid compiler warnings Q_UNUSED(argc) Q_UNUSED(argv) QString s1(&#34;Paris&#34;); QString s2(&#34;London&#34;); // string concatenation QString s = s1 &#43; &#34; &#34; &#43; s2 &#43; &#34;!&#34;; cout &lt;&lt; s &lt;&lt; endl; } 容器类
这个例子在应用程序中增加了一个链表和一个链表迭代器。Qt自带大量方便使用的容器类，并且其中的元素使用相同的应用程序接口模式。
QString s1(&#34;Hello&#34;); QString s2(&#34;Qt&#34;); QList&lt;QString&gt; list; // stream into containers list &lt;&lt; s1 &lt;&lt; s2; // Java and STL like iterators QListIterator&lt;QString&gt; iter(list); while(iter.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="应用程序类型（Application Types） #  这一节贯穿了可能使用Qt5编写的不同类型的应用程序。没有任何建议的选择，只是想告诉读者Qt5通常情况下能做些什么。
2.3.1 控制台应用程序 #  一个控制台应用程序不需要提供任何人机交互图形界面通常被称作系统服务，或者通过命令行来运行。Qt5附带了一系列现成的组件来帮助你非常有效的创建跨平台的控制台应用程序。例如网络应用程序编程接口或者文件应用程序编程接口，字符串的处理，自Qt5.1发布的高效的命令解析器。由于Qt是基于C&#43;&#43;的高级应用程序接口，你能够快速的编程并且程序拥有快速的执行速度。不要认为Qt仅仅只是用户界面工具，它也提供了许多其它的功能。
字符串处理
在第一个例子中我们展示了怎样简单的增加两个字符串常量。这不是一个有用的应用程序，但能让你了解本地端C&#43;&#43;应用程序没有事件循环时是什么样的。
// module or class includes #include &lt;QtCore&gt; // text stream is text-codec aware QTextStream cout(stdout, QIODevice::WriteOnly); int main(int argc, char** argv) { // avoid compiler warnings Q_UNUSED(argc) Q_UNUSED(argv) QString s1(&#34;Paris&#34;); QString s2(&#34;London&#34;); // string concatenation QString s = s1 &#43; &#34; &#34; &#43; s2 &#43; &#34;!&#34;; cout &lt;&lt; s &lt;&lt; endl; } 容器类
这个例子在应用程序中增加了一个链表和一个链表迭代器。Qt自带大量方便使用的容器类，并且其中的元素使用相同的应用程序接口模式。
QString s1(&#34;Hello&#34;); QString s2(&#34;Qt&#34;); QList&lt;QString&gt; list; // stream into containers list &lt;&lt; s1 &lt;&lt; s2; // Java and STL like iterators QListIterator&lt;QString&gt; iter(list); while(iter." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mirrors.cqu.edu.cn/qmlbook/get_start/application_types/" /><meta property="article:section" content="get_start" />



<title>Application Types | Qml Book</title>
<link rel="manifest" href="/qmlbook/manifest.json">
<link rel="icon" href="/qmlbook/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/qmlbook/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css" integrity="sha256-l8/aT148n6SaK/jUAfTdwO7Fdsmc3PavvsGRcyAMN9s=" crossorigin="anonymous">
  <script defer src="/qmlbook/flexsearch.min.js"></script>
  <script defer src="/qmlbook/en.search.min.7eaa324ae4aad96718321da9bf7ce2963bf997813e848e1e16bcc0e89048af9b.js" integrity="sha256-fqoySuSq2WcYMh2pv3ziljv5l4E&#43;hI4eFrzA6JBIr5s=" crossorigin="anonymous"></script>

  <script defer src="/qmlbook/sw.min.c5fd65d1492edd0e92acb72a8983e44a68ad14c15883246783ed1d96f25e6858.js" integrity="sha256-xf1l0Uku3Q6SrLcqiYPkSmitFMFYgyRng&#43;0dlvJeaFg=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/qmlbook/"><span>Qml Book</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <h1 id="summary">
  Summary
  <a class="anchor" href="#summary">#</a>
</h1>
<ul>
<li>
  <a href="/qmlbook/README/">Introduction</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/README/">Qt5概述</a>
<ul>
<li>
  <a href="/qmlbook/meet_qt_5/preface/">序</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt5_introduction/">Qt5介绍</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt_building_blocks/">Qt构建模块（Qt Building Blocks）</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt_project/">Qt项目（Qt Project）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/get_start/README/">开始学习（Get Start）</a>
<ul>
<li>
  <a href="/qmlbook/get_start/qt5installing_qt_5_sdk/">安装Qt5软件工具包（Installing Qt 5 SDK）</a></li>
<li>
  <a href="/qmlbook/get_start/hello_world/">你好世界（Hello World）</a></li>
<li>
  <a href="/qmlbook/get_start/application_types/"class=active>应用程序类型（Application Types）</a></li>
<li>
  <a href="/qmlbook/get_start/summary/">总结（ Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_creator_ide/README/">Qt Creator集成开发环境（Qt Creator IDE）</a>
<ul>
<li>
  <a href="/qmlbook/qt_creator_ide/the_user_interface/">用户界面（The User Interface）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/qtregistering_your_qt_kit/">注册你的Qt工具箱（Registering your Qt Kit）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/managing_projects/">项目管理（Managing Projects）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/using_the_editor/">使用编辑器（Using the Editor）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/locator/">定位器（Locator）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/debugging/">调试（Debugging）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/shortcuts/">快捷键（Shortcuts）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/quick_starter/README/">QML快速入门（Quick Starter）</a>
<ul>
<li>
  <a href="/qmlbook/quick_starter/qmlqml_syntax/">QML语法（QML Syntax）</a></li>
<li>
  <a href="/qmlbook/quick_starter/basic_elements/">基本元素（Basic Elements）</a></li>
<li>
  <a href="/qmlbook/quick_starter/compontents/">组件（Compontents）</a></li>
<li>
  <a href="/qmlbook/quick_starter/simple_transformations/">简单的转换（Simple Transformations）</a></li>
<li>
  <a href="/qmlbook/quick_starter/positioning_element/">定位元素（Positioning Element）</a></li>
<li>
  <a href="/qmlbook/quick_starter/layout_items/">布局元素（Layout Items）</a></li>
<li>
  <a href="/qmlbook/quick_starter/input_element/">输入元素（Input Element）</a></li>
<li>
  <a href="/qmlbook/quick_starter/advanced_techniques/"> 高级用法（Advanced Techniques）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/fluid_elements/README/">动态元素（Fluid Elements）</a>
<ul>
<li>
  <a href="/qmlbook/fluid_elements/animations/">动画（Animations）</a></li>
<li>
  <a href="/qmlbook/fluid_elements/states_and_transitions/">状态与过渡（States and Transitions）</a></li>
<li>
  <a href="/qmlbook/fluid_elements/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/model-view-delegate/README/">模型-视图-代理（Model-View-Delegate）</a>
<ul>
<li>
  <a href="/qmlbook/model-view-delegate/concept/">概念（Concept）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/basic_model/">基础模型（Basic Model）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/dynamic_views/">动态视图（Dynamic Views）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/delegate/">代理（Delegate）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/canvas_element/README/">画布元素（Canvas Element）</a>
<ul>
<li>
  <a href="/qmlbook/canvas_element/convenient_api/">便捷的接口（Convenient API）</a></li>
<li>
  <a href="/qmlbook/canvas_element/gradients/">渐变（Gradients）</a></li>
<li>
  <a href="/qmlbook/canvas_element/shadows/">阴影（Shadows）</a></li>
<li>
  <a href="/qmlbook/canvas_element/images/">图片（Images）</a></li>
<li>
  <a href="/qmlbook/canvas_element/transformation/">转换（Transformation）</a></li>
<li>
  <a href="/qmlbook/canvas_element/composition_mode/">组合模式（Composition Mode）</a></li>
<li>
  <a href="/qmlbook/canvas_element/pixels_buffer/">像素缓冲（Pixels Buffer）</a></li>
<li>
  <a href="/qmlbook/canvas_element/canvas_paint/">画布绘制（Canvas Paint）</a></li>
<li>
  <a href="/qmlbook/canvas_element/html5porting_from_html5_canvas/">HTML5画布移植（Porting from HTML5 Canvas）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/particle_simulations/README/">粒子模拟（Particle Simulations）</a>
<ul>
<li>
  <a href="/qmlbook/particle_simulations/concept/">概念（Concept）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/simple_simulation/">简单的模拟（Simple Simulation）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_parameters/">粒子参数（Particle Parameters）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/directed_particle/">粒子方向（Directed Particle）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_painter/">粒子画笔（Particle Painter）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/affecting_particles/">粒子控制（Affecting Particles）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_group/">粒子组（Particle Group）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/shader_effect/README/">着色器效果（Shader Effect）</a>
<ul>
<li>
  <a href="/qmlbook/shader_effect/openglopengl_shader/">OpenGL着色器（OpenGL Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/shader_elements/">着色器元素（Shader Elements）</a></li>
<li>
  <a href="/qmlbook/shader_effect/fragement_shader/">片段着色器（Fragement Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/wave_effect/">波浪效果（Wave Effect）</a></li>
<li>
  <a href="/qmlbook/shader_effect/vertex_shader/">顶点着色器（Vertex Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/curtain_effect/">剧幕效果（Curtain Effect）</a></li>
<li>
  <a href="/qmlbook/shader_effect/qtqt_graphicseffect_library/">Qt图像效果库（Qt GraphicsEffect Library）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/multimedia/README/">多媒体（Multimedia）</a>
<ul>
<li>
  <a href="/qmlbook/multimedia/playing_media/">媒体播放（Playing Media）</a></li>
<li>
  <a href="/qmlbook/multimedia/sounds_effects/">声音效果（Sounds Effects）</a></li>
<li>
  <a href="/qmlbook/multimedia/video_streams/">视频流（Video Streams）</a></li>
<li>
  <a href="/qmlbook/multimedia/capturing_images/">捕捉图像（Capturing Images）</a></li>
<li>
  <a href="/qmlbook/multimedia/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
<li>
  <a href="/qmlbook/multimedia/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/networking/README/">网络（Networking）</a>
<ul>
<li>
  <a href="/qmlbook/networking/httpuiserving_ui_via_http/">通过HTTP服务用户界面（Serving UI via HTTP）</a></li>
<li>
  <a href="/qmlbook/networking/templating/">模板（Templating）</a></li>
<li>
  <a href="/qmlbook/networking/httphttp_requests/">HTTP请求（HTTP Requests）</a></li>
<li>
  <a href="/qmlbook/networking/local_files/">本地文件（Local files）</a></li>
<li>
  <a href="/qmlbook/networking/restrest_api/">REST接口（REST API）</a></li>
<li>
  <a href="/qmlbook/networking/authentication_using_oauth/">使用开放授权登陆验证（Authentication using OAuth）</a></li>
<li>
  <a href="/qmlbook/networking/engine_io/">云服务（Engine IO）</a></li>
<li>
  <a href="/qmlbook/networking/web_sockets/">Web Sockets</a></li>
<li>
  <a href="/qmlbook/networking/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/storage/README/">存储（Storage）</a>
<ul>
<li>
  <a href="/qmlbook/storage/settings/">配置（Settings）</a></li>
<li>
  <a href="/qmlbook/storage/local_storage_-_sql/">本地存储 - SQL（Local Storage - SQL）</a></li>
<li>
  <a href="/qmlbook/storage/other_storage_apis/">其它存储接口（Other Storage APIs）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/README/">动态QML（Dynamic QML）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/loading_components_dynamically/">动态加载组件（Loading Components Dynamically）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/connecting_indirectly/">间接连接（Connecting Indirectly）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/binding_indirectly/">间接绑定（Binding Indirectly）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/creating_and_destroying_objects/">创建与销毁对象（Creating and Destroying Objects）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/dynamically_loading_and_instantiating_items/">动态加载和实例化项（Dynamically Loading and Instantiating Items）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/dynamically_instantiating_items_from_text/">从文本中动态实例化项（Dynamically Instantiating Items from Text）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/managing_dynamically_created_elements/">管理动态创建的元素（Managing Dynamically Created Elements）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/tracking_dynamic_objects/">跟踪动态对象（Tracking Dynamic Objects）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/javascript/README/">JavaScript</a>
<ul>
<li>
  <a href="/qmlbook/javascript/browserhtml_vs_qtquickqml/">浏览器/HTML与QtQuick/QML对比（Browser/HTML vs QtQuick/QML）</a></li>
<li>
  <a href="/qmlbook/javascript/the_language/">JavaScript语法（The Language）</a></li>
<li>
  <a href="/qmlbook/javascript/js_objects/">JS对象（JS Objects）</a></li>
<li>
  <a href="/qmlbook/javascript/creating_a_js_console/">创建JS控制台（Creating a JS Console）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/README/">Qt and C++</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/a_boilerplate_application/">演示程序（A Boilerplate Application）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/the_qobject/">Qt对象（The QObject）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/build_systems/">编译系统（Build Systems）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/qmake/">QMake</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/cmake/">CMake</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/common_qt_classes/">Qt通用类（Common Qt Classes）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/qstring/">QString</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/sequential_containers/">顺序容器（Sequential Containers）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/associative_containers/">组合容器（Associative Containers）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/file_io/">文件IO（File IO）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/models_in_c&#43;&#43;/">C++数据模型（Models in C++）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/a_simple_model/">一个简单的模型（A simple model）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/more_complex_data/">更复杂的数据（More Complex Data）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/dynamic_data/">动态数据（Dynamic Data）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/advanced_techniques/">进阶技巧（Advanced Techniques）</a></li>
</ul>
</li>
</ul>
</li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/README/">C++扩展QML（Extending QML with C++）</a>
<ul>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/understanding_the_qml_run-time/">理解QML运行环境（Understanding the QML Run-time）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/plugin_content/">插件内容（Plugin Content）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/creating_the_plugin/">创建插件（Creating the plugin）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/fileio_implementation/">FileIO实现（FileIO Implementation）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/using_fileio/">使用FileIO（Using FileIO）</a>
<ul>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/the_application_window/">应用程序窗口（The Application Window）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/using_actions/">使用动作（Using Actions）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/formatting_the_table/">格式化表格（Formatting the Table）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/reading_data/">读取数据（Reading Data）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/writing_data/">写入数据（Writing Data）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/finishing_touch/">收尾工作（Finishing Touch）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/other/README/">其它（Other）</a>
<ul>
<li>
  <a href="/qmlbook/other/assets/">示例源码</a></li>
<li>
  <a href="/qmlbook/other/enginsh_to_chinses/">术语英汉对照表</a></li>
<li>
  <a href="/qmlbook/other/book_format/">格式定义</a></li>
<li>
  <a href="/qmlbook/other/collaboration_correction/">协作校正</a></li>
</ul>
</li>
</ul>






  
<ul>
  
  <li>
    <a href="https://github.com/cwc1987/QmlBook-In-Chinese" target="_blank" rel="noopener">
        QmlBook In Chinese
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/qmlbook/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Application Types</strong>

  <label for="toc-control">
    
    <img src="/qmlbook/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#应用程序类型application-types">应用程序类型（Application Types）</a>
      <ul>
        <li><a href="#231-控制台应用程序">2.3.1 控制台应用程序</a></li>
        <li><a href="#232-窗口应用程序">2.3.2 窗口应用程序</a></li>
        <li><a href="#233-数据适配">2.3.3 数据适配</a></li>
        <li><a href="#234-qt-quick应用程序">2.3.4 Qt Quick应用程序</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="应用程序类型application-types">
  应用程序类型（Application Types）
  <a class="anchor" href="#%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e7%b1%bb%e5%9e%8bapplication-types">#</a>
</h1>
<p>这一节贯穿了可能使用Qt5编写的不同类型的应用程序。没有任何建议的选择，只是想告诉读者Qt5通常情况下能做些什么。</p>
<h2 id="231-控制台应用程序">
  2.3.1 控制台应用程序
  <a class="anchor" href="#231-%e6%8e%a7%e5%88%b6%e5%8f%b0%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f">#</a>
</h2>
<p>一个控制台应用程序不需要提供任何人机交互图形界面通常被称作系统服务，或者通过命令行来运行。Qt5附带了一系列现成的组件来帮助你非常有效的创建跨平台的控制台应用程序。例如网络应用程序编程接口或者文件应用程序编程接口，字符串的处理，自Qt5.1发布的高效的命令解析器。由于Qt是基于C++的高级应用程序接口，你能够快速的编程并且程序拥有快速的执行速度。不要认为Qt仅仅只是用户界面工具，它也提供了许多其它的功能。</p>
<p><strong>字符串处理</strong></p>
<p>在第一个例子中我们展示了怎样简单的增加两个字符串常量。这不是一个有用的应用程序，但能让你了解本地端C++应用程序没有事件循环时是什么样的。</p>
<pre tabindex="0"><code>// module or class includes
#include &lt;QtCore&gt;

// text stream is text-codec aware
QTextStream cout(stdout, QIODevice::WriteOnly);

int main(int argc, char** argv)
{
    // avoid compiler warnings
    Q_UNUSED(argc)
    Q_UNUSED(argv)
    QString s1(&#34;Paris&#34;);
    QString s2(&#34;London&#34;);
    // string concatenation
    QString s = s1 + &#34; &#34; + s2 + &#34;!&#34;;
    cout &lt;&lt; s &lt;&lt; endl;
}
</code></pre><p><strong>容器类</strong></p>
<p>这个例子在应用程序中增加了一个链表和一个链表迭代器。Qt自带大量方便使用的容器类，并且其中的元素使用相同的应用程序接口模式。</p>
<pre tabindex="0"><code>QString s1(&#34;Hello&#34;);
QString s2(&#34;Qt&#34;);
QList&lt;QString&gt; list;
// stream into containers
list &lt;&lt;  s1 &lt;&lt; s2;
// Java and STL like iterators
QListIterator&lt;QString&gt; iter(list);
while(iter.hasNext()) {
    cout &lt;&lt; iter.next();
    if(iter.hasNext()) {
        cout &lt;&lt; &#34; &#34;;
    }
}
cout &lt;&lt; &#34;!&#34; &lt;&lt; endl;
</code></pre><p>这里我们展示了一些高级的链表函数，允许你在一个字符串中加入一个链表的字符串。当你需要持续的文本输入时非常的方便。使用QString::split()函数可以将这个操作逆向（将字符串转换为字符串链表）。</p>
<pre tabindex="0"><code>QString s1(&#34;Hello&#34;);
QString s2(&#34;Qt&#34;);
// convenient container classes
QStringList list;
list &lt;&lt;  s1 &lt;&lt; s2;
// join strings
QString s = list.join(&#34; &#34;) + &#34;!&#34;;
cout &lt;&lt; s &lt;&lt; endl;
</code></pre><p><strong>文件IO</strong></p>
<p>下一个代码片段我们从本地读取了一个CSV文件并且遍历提取每一行的每一个单元的数据。我们从CSV文件中获取大约20行的编码。文件读取仅仅给了我们一个比特流，为了有效的将它转换为可以使用的Unicode文本，我们需要使用这个文件作为文本流的底层流数据。编写CSV文件，你只需要以写入的方式打开一个文件并且一行一行的输入到文件流中。</p>
<pre tabindex="0"><code>QList&lt;QStringList&gt; data;
// file operations
QFile file(&#34;sample.csv&#34;);
if(file.open(QIODevice::ReadOnly)) {
    QTextStream stream(&amp;file);
    // loop forever macro
    forever {
        QString line = stream.readLine();
        // test for empty string &#39;QString(&#34;&#34;)&#39;
        if(line.isEmpty()) {
            continue;
        }
        // test for null string &#39;String()&#39;
        if(line.isNull()) {
            break;
        }
        QStringList row;
        // for each loop to iterate over containers
        foreach(const QString&amp; cell, line.split(&#34;,&#34;)) {
            row.append(cell.trimmed());
        }
        data.append(row);
    }
}
// No cleanup necessary.
</code></pre><p>现在我们结束Qt关于基于控制台应用程序小节。</p>
<h2 id="232-窗口应用程序">
  2.3.2 窗口应用程序
  <a class="anchor" href="#232-%e7%aa%97%e5%8f%a3%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f">#</a>
</h2>
<p>基于控制台的应用程序非常方便，但是有时候你需要有一些用户界面。但是基于用户界面的应用程序需要后端来写入/读取文件，使用网络进行通讯或者保存数据到一个容器中。</p>
<p>在第一个基于窗口的应用程序代码片段，我们仅仅只创建了一个窗口并显示它。没有父对象的窗口部件是Qt世界中的一个窗口。我们使用智能指针来确保当智能指针指向范围外时窗口会被删除掉。</p>
<p>这个应用程序对象封装了Qt的运行，调用exec开始我们的事件循环。从这里开始我们的应用程序只响应由鼠标或者键盘或者其它的例如网络或者文件IO的事件触发。应用程序也只有在事件循环退出时才退出，在应用程序中调用&quot;quit()&ldquo;或者关掉窗口来退出。
当你运行这段代码的时候你可以看到一个240乘以120像素的窗口。</p>
<pre tabindex="0"><code>#include &lt;QtGui&gt;

int main(int argc, char** argv)
{
    QApplication app(argc, argv);
    QScopedPointer&lt;QWidget&gt; widget(new CustomWidget());
    widget-&gt;resize(240, 120);
    widget-&gt;show();
    return app.exec();
}
</code></pre><p><strong>自定义窗口部件</strong></p>
<p>当你使用用户界面时你需要创建一个自定义的窗口部件。典型的窗口是一个窗口部件区域的绘制调用。附加一些窗口部件内部如何处理外部触发的键盘或者鼠标输入。为此我们需要继承QWidget并且重写几个函数来绘制和处理事件。</p>
<pre tabindex="0"><code>#ifndef CUSTOMWIDGET_H
#define CUSTOMWIDGET_H

#include &lt;QtWidgets&gt;

class CustomWidget : public QWidget
{
    Q_OBJECT
public:
    explicit CustomWidget(QWidget *parent = 0);
    void paintEvent(QPaintEvent *event);
    void mousePressEvent(QMouseEvent *event);
    void mouseMoveEvent(QMouseEvent *event);
private:
    QPoint m_lastPos;
};

#endif // CUSTOMWIDGET_H
</code></pre><p>在实现中我们绘制了窗口的边界并在鼠标最后的位置上绘制了一个小的矩形框。这是一个非常典型的低层次的自定义窗口部件。鼠标或者键盘事件会改变窗口的内部状态并触发重新绘制。我们不需要更加详细的分析这个代码，你应该有能力分析它。Qt自带了大量现成的桌面窗口部件，你有很大的几率不需要再做这些工作。</p>
<pre tabindex="0"><code>#include &#34;customwidget.h&#34;

CustomWidget::CustomWidget(QWidget *parent) :
    QWidget(parent)
{
}

void CustomWidget::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    QRect r1 = rect().adjusted(10,10,-10,-10);
    painter.setPen(QColor(&#34;#33B5E5&#34;));
    painter.drawRect(r1);

    QRect r2(QPoint(0,0),QSize(40,40));
    if(m_lastPos.isNull()) {
        r2.moveCenter(r1.center());
    } else {
        r2.moveCenter(m_lastPos);
    }
    painter.fillRect(r2, QColor(&#34;#FFBB33&#34;));
}

void CustomWidget::mousePressEvent(QMouseEvent *event)
{
    m_lastPos = event-&gt;pos();
    update();
}

void CustomWidget::mouseMoveEvent(QMouseEvent *event)
{
    m_lastPos = event-&gt;pos();
    update();
}
</code></pre><p><strong>桌面窗口</strong></p>
<p>Qt的开发者们已经为你做好大量现成的桌面窗口部件，在不同的操作系统中他们看起来都像是本地的窗口部件。你的工作只需要在一个打的窗口容器中安排不同的的窗口部件。在Qt中一个窗口部件能够包含其它的窗口部件。这个操作由分配父子关系来完成。这意味着我们需要准备类似按钮（button），复选框（check box），单选按钮（radio button）的窗口部件并且对它们进行布局。下面展示了一种完成的方法。</p>
<p>这里有一个头文件就是所谓的窗口部件容器。</p>
<pre tabindex="0"><code>class CustomWidget : public QWidget
{
    Q_OBJECT
public:
    explicit CustomWidgetQWidget *parent = 0);
private slots:
    void itemClicked(QListWidgetItem* item);
    void updateItem();
private:
    QListWidget *m_widget;
    QLineEdit *m_edit;
    QPushButton *m_button;
};
</code></pre><p>在实现中我们使用布局来更好的安排我们的窗口部件。当容器窗口部件大小被改变后它会按照窗口部件的大小策略进行重新布局。在这个例子中我们有一个链表窗口部件，行编辑器与按钮垂直排列来编辑一个城市的链表。我们使用Qt的信号与槽来连接发送和接收对象。</p>
<pre tabindex="0"><code>CustomWidget::CustomWidget(QWidget *parent) :
    QWidget(parent)
{
    QVBoxLayout *layout = new QVBoxLayout(this);
    m_widget = new QListWidget(this);
    layout-&gt;addWidget(m_widget);

    m_edit = new QLineEdit(this);
    layout-&gt;addWidget(m_edit);

    m_button = new QPushButton(&#34;Quit&#34;, this);
    layout-&gt;addWidget(m_button);
    setLayout(layout);

    QStringList cities;
    cities &lt;&lt; &#34;Paris&#34; &lt;&lt; &#34;London&#34; &lt;&lt; &#34;Munich&#34;;
    foreach(const QString&amp; city, cities) {
        m_widget-&gt;addItem(city);
    }

    connect(m_widget, SIGNAL(itemClicked(QListWidgetItem*)), this, SLOT(itemClicked(QListWidgetItem*)));
    connect(m_edit, SIGNAL(editingFinished()), this, SLOT(updateItem()));
    connect(m_button, SIGNAL(clicked()), qApp, SLOT(quit()));
}

void CustomWidget::itemClicked(QListWidgetItem *item)
{
    Q_ASSERT(item);
    m_edit-&gt;setText(item-&gt;text());
}

void CustomWidget::updateItem()
{
    QListWidgetItem* item = m_widget-&gt;currentItem();
    if(item) {
        item-&gt;setText(m_edit-&gt;text());
    }
}
</code></pre><p><strong>绘制图形</strong></p>
<p>有一些问题最好用可视化的方式表达。如果手边的问题看起来有点像几何对象，qt graphics view是一个很好的选择。一个图形视窗（graphics view）能够在一个场景（scene）排列简单的几何图形。用户可以与这些图形交互，它们使用一定的算法放置在场景（scene）上。填充一个图形视图你需要一个图形窗口（graphics view）和一个图形场景（graphics scene）。一个图形场景（scene）连接在一个图形窗口（view）上，图形对象（graphics item）是被放在图形场景（scene）上的。这里有一个简单的例子，首先头文件定义了图形窗口（view）与图形场景（scene）。</p>
<pre tabindex="0"><code>class CustomWidgetV2 : public QWidget
{
    Q_OBJECT
public:
    explicit CustomWidgetV2(QWidget *parent = 0);
private:
    QGraphicsView *m_view;
    QGraphicsScene *m_scene;

};
</code></pre><p>在实现中首先将图形场景（scene）与图形窗口（view）连接。图形窗口（view）是一个窗口部件，能够被我们的窗口部件容器包含。最后我们添加一个小的矩形框在图形场景（scene）中。然后它会被渲染到我们的图形窗口（view）上。</p>
<pre tabindex="0"><code>#include &#34;customwidgetv2.h&#34;

CustomWidget::CustomWidget(QWidget *parent) :
    QWidget(parent)
{
    m_view = new QGraphicsView(this);
    m_scene = new QGraphicsScene(this);
    m_view-&gt;setScene(m_scene);

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout-&gt;setMargin(0);
    layout-&gt;addWidget(m_view);
    setLayout(layout);

    QGraphicsItem* rect1 = m_scene-&gt;addRect(0,0, 40, 40, Qt::NoPen, QColor(&#34;#FFBB33&#34;));
    rect1-&gt;setFlags(QGraphicsItem::ItemIsFocusable|QGraphicsItem::ItemIsMovable);
}
</code></pre><h2 id="233-数据适配">
  2.3.3 数据适配
  <a class="anchor" href="#233-%e6%95%b0%e6%8d%ae%e9%80%82%e9%85%8d">#</a>
</h2>
<p>到现在我们已经知道了大多数的基本数据类型，并且知道如何使用窗口部件和图形视图（graphics views）。通常在应用程序中你需要处理大量的结构体数据，也可能需要不停的储存它们，或者这些数据需要被用来显示。对于这些Qt使用了模型的概念。下面一个简单的模型是字符串链表模型，它被一大堆字符串填满然后与一个链表视图（list view）连接。</p>
<pre tabindex="0"><code>m_view = new QListView(this);
m_model = new QStringListModel(this);
view-&gt;setModel(m_model);

QList&lt;QString&gt; cities;
cities &lt;&lt; &#34;Munich&#34; &lt;&lt; &#34;Paris&#34; &lt;&lt; &#34;London&#34;;
model-&gt;setStringList(cities);
</code></pre><p>另一个比较普遍的用法是使用SQL（结构化数据查询语言）来存储和读取数据。Qt自身附带了嵌入式版的SQLLite并且也支持其它的数据引擎（比如MySQL，PostgresSQL，等等）。首先你需要使用一个模式来创建你的数据库，比如像这样：</p>
<pre tabindex="0"><code>CREATE TABLE city (name TEXT, country TEXT);
INSERT INTO city value (&#34;Munich&#34;, &#34;Germany&#34;);
INSERT INTO city value (&#34;Paris&#34;, &#34;France&#34;);
INSERT INTO city value (&#34;London&#34;, &#34;United Kingdom&#34;);
</code></pre><p>为了能够在使用sql，我们需要在我们的项目文件（*.pro）中加入sql模块。</p>
<pre tabindex="0"><code>QT += sql
</code></pre><p>然后我们需要c++来打开我们的数据库。首先我们需要获取一个指定的数据库引擎的数据对象。使用这个数据库对象我们可以打开数据库。对于SQLLite这样的数据库我们可以指定一个数据库文件的路径。Qt提供了一些高级的数据库模型，其中有一种表格模型（table model）使用表格标示符和一个选项分支语句（where clause）来选择数据。这个模型的结果能够与一个链表视图连接，就像之前连接其它数据模型一样。</p>
<pre tabindex="0"><code>QSqlDatabase db = QSqlDatabase::addDatabase(&#34;QSQLITE&#34;);
db.setDatabaseName(&#39;cities.db&#39;);
if(!db.open()) {
    qFatal(&#34;unable to open database&#34;);
}

m_model = QSqlTableModel(this);
m_model-&gt;setTable(&#34;city&#34;);
m_model-&gt;setHeaderData(0, Qt::Horizontal, &#34;City&#34;);
m_model-&gt;setHeaderData(1, Qt::Horizontal, &#34;Country&#34;);

view-&gt;setModel(m_model);
m_model-&gt;select();
</code></pre><p>对高级的模型操作，Qt提供了一种分类文件代理模型，允许你使用基础的分类排序和数据过滤来操作其它的模型。</p>
<pre tabindex="0"><code>QSortFilterProxyModel* proxy = new QSortFilterProxyModel(this);
proxy-&gt;setSourceModel(m_model);
view-&gt;setModel(proxy);
view-&gt;setSortingEnabled(true);
</code></pre><p>数据过滤基于列号与一个字符串参数完成。</p>
<pre tabindex="0"><code>proxy-&gt;setFilterKeyColumn(0);
proxy-&gt;setFilterCaseSensitive(Qt::CaseInsensitive);
proxy-&gt;setFilterFixedString(QString)
</code></pre><p>过滤代理模型比这里演示的要强大的多，现在我们只需要知道有它的存在就够了。</p>
<p><strong>注意</strong></p>
<p><strong>这里是综述了你可以在Qt5中开发的不同类型的经典应用程序。桌面应用程序正在发生着改变，不久之后移动设备将会为占据我们的世界。移动设备的用户界面设计非常不同。它们相对于桌面应用程序更加简洁，只需要专注的做一件事情。动画效果是一个非常重要的部分，用户界面需要生动活泼。传统的Qt技术已经不适于这些市场了。</strong></p>
<p><strong>接下来：Qt Quick将会解决这个问题。</strong></p>
<h2 id="234-qt-quick应用程序">
  2.3.4 Qt Quick应用程序
  <a class="anchor" href="#234-qt-quick%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f">#</a>
</h2>
<p>在现代的软件开发中有一个内在的冲突，用户界面的改变速度远远高于我们的后端服务。在传统的技术中我们开发的前端需要与后端保持相同的步调。当一个项目在开发时用户想要改变用户界面，或者在一个项目中开发一个用户界面的想法就会引发这个冲突。敏捷项目需要敏捷的方法。</p>
<p>Qt Quick 提供了一个类似HTML声明语言的环境应用程序作为你的用户界面前端（the front-end），在你的后端使用本地的c++代码。这样允许你在两端都游刃有余。</p>
<p>下面是一个简单的Qt Quick UI的例子。</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 240; height: 1230
    Rectangle {
        width: 40; height: 40
        anchors.centerIn: parent
        color: &#39;#FFBB33&#39;
    }
}
</code></pre><p>这种声明语言被称作QML，它需要在运行时启动。Qt提供了一个典型的运行环境叫做qmlscene，但是想要写一个自定义的允许环境也不是很困难，我们需要一个快速视图（quick view）并且将QML文档作为它的资源。剩下的事情就只是展示我们的用户界面了。</p>
<pre tabindex="0"><code>QQuickView* view = new QQuickView();
QUrl source = Qurl::fromLocalUrl(&#34;main.qml&#34;);
view-&gt;setSource(source);
view.show();
</code></pre><p>回到我们之前的例子，在一个例子中我们使用了一个c++的城市数据模型。如果我们能够在QML代码中使用它将会更加的好。</p>
<p>为了实现它我们首先要编写前端代码怎样展示我们需要使用的城市数据模型。在这一个例子中前端指定了一个对象叫做cityModel，我们可以在链表视图（list view）中使用它。</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 240; height: 120
    ListView {
        width: 180; height: 120
        anchors.centerIn: parent
        model: cityModel
        delegate: Text { text: model.city }
    }
}
</code></pre><p>为了使用cityModel，我们通常需要重复使用我们以前的数据模型，给我们的根环境（root context）加上一个内容属性（context property）。（root context是在另一个文档的根元素中）。</p>
<pre tabindex="0"><code>m_model = QSqlTableModel(this);
... // some magic code
QHash&lt;int, QByteArray&gt; roles;
roles[Qt::UserRole+1] = &#34;city&#34;;
roles[Qt::UserRole+2] = &#34;country&#34;;
m_model-&gt;setRoleNames(roles);
view-&gt;rootContext()-&gt;setContextProperty(&#34;cityModel&#34;, m_model);
</code></pre><p><strong>警告</strong></p>
<p><strong>这不是完全正确的用法，作为包含在SQL表格模型列中的数据，一个QML模型的任务是来表达这些数据。所以需要做一个在列和任务之间的映射关系。请查看来
  <a href="http://qt-project.org/wiki/QML_and_QSqlTableModel">QML and QSqlTableModel</a>获得更多的信息。</strong></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#应用程序类型application-types">应用程序类型（Application Types）</a>
      <ul>
        <li><a href="#231-控制台应用程序">2.3.1 控制台应用程序</a></li>
        <li><a href="#232-窗口应用程序">2.3.2 窗口应用程序</a></li>
        <li><a href="#233-数据适配">2.3.3 数据适配</a></li>
        <li><a href="#234-qt-quick应用程序">2.3.4 Qt Quick应用程序</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












