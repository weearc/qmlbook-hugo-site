<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="动态视图（Dynamic Views） #  Repeater元素适合有限的静态数据，但是在真正使用时，模型通常更加复杂和庞大，我们需要一个更加智能的解决方案。QtQuick提供了ListView和GridView元素，这两个都是基于Flickable（可滑动）区域的元素，因此用户可以放入更大的数据。同时，它们限制了同时实例化的代理数量。对于一个大型的模型，这意味着在同一个场景下只会加载有限的元素。
  这两个元素的用法非常类似，我们由ListView开始，然后会描述GridView的模型起点来进行比较。
ListView与Repeater元素像素，它使用了一个model，使用delegate来实例化，并且在两个delegate之间能够设置间隔sapcing。下面的列表显示了怎样设置一个简单的链表。
import QtQuick 2.0 Rectangle { width: 80 height: 300 color: &#34;white&#34; ListView { anchors.fill: parent anchors.margins: 20 clip: true model: 100 delegate: numberDelegate spacing: 5 } Component { id: numberDelegate Rectangle { width: 40 height: 40 color: &#34;lightGreen&#34; Text { anchors.centerIn: parent font.pixelSize: 10 text: index } } } }  如果模型包含的数据比屏幕上显示的更多，ListView元素只会显示部分的链表内容。然后由于QtQuick的默认行为导致的问题，列表视图不会限制被显示的代理项（delegates）只在限制区域内显示。这意味着代理项可以在列表视图外显示，用户可以看见在列表视图外动态的创建和销毁这些代理项（delegates）。为了防止这个问题，ListView通过设置clip属性为true，来激活裁剪功能。下面的图片展示了这个结果，左边是clip属性设置为false的对比。
 对于用户，ListView（列表视图）是一个滚动区域。它支持惯性滚动，这意味着它可以快速的翻阅内容。默认模式下，它可以在内容最后继续伸展，然后反弹回去，这个信号告诉用户已经到达内容的末尾。
视图末尾的行为是由到boundsBehavior属性的控制的。这是一个枚举值，并且可以配置为默认的Flickable.DragAndOvershootBounds，视图可以通过它的边界线来拖拽和翻阅，配置为Flickable.StopAtBounds，视图将不再可以移动到它的边界线之外。配置为Flickable.DragOverBounds，用户可以将视图拖拽到它的边界线外，但是在边界线上翻阅将无效。
使用snapMode属性可以限制一个视图内元素的停止位置。默认行为下是ListView.NoSnap，允许视图内元素在任何位置停止。将snapMode属性设置为ListView.SnapToItem，视图顶部将会与元素对象的顶部对齐排列。使用ListView.SnapOneItem，当鼠标或者触摸释放时，视图将会停止在第一个可见的元素，这种模式对于浏览页面非常便利。
6.3.1 方向（Orientation） #  默认的链表视图只提供了一个垂直方向的滚动条，但是水平滚动条也是需要的。链表视图的方向由属性orientation控制。它能够被设置为默认值ListView.Vertical或者ListView.Horizontal。下面是一个水平链表视图。">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="动态视图（Dynamic Views） #  Repeater元素适合有限的静态数据，但是在真正使用时，模型通常更加复杂和庞大，我们需要一个更加智能的解决方案。QtQuick提供了ListView和GridView元素，这两个都是基于Flickable（可滑动）区域的元素，因此用户可以放入更大的数据。同时，它们限制了同时实例化的代理数量。对于一个大型的模型，这意味着在同一个场景下只会加载有限的元素。
  这两个元素的用法非常类似，我们由ListView开始，然后会描述GridView的模型起点来进行比较。
ListView与Repeater元素像素，它使用了一个model，使用delegate来实例化，并且在两个delegate之间能够设置间隔sapcing。下面的列表显示了怎样设置一个简单的链表。
import QtQuick 2.0 Rectangle { width: 80 height: 300 color: &#34;white&#34; ListView { anchors.fill: parent anchors.margins: 20 clip: true model: 100 delegate: numberDelegate spacing: 5 } Component { id: numberDelegate Rectangle { width: 40 height: 40 color: &#34;lightGreen&#34; Text { anchors.centerIn: parent font.pixelSize: 10 text: index } } } }  如果模型包含的数据比屏幕上显示的更多，ListView元素只会显示部分的链表内容。然后由于QtQuick的默认行为导致的问题，列表视图不会限制被显示的代理项（delegates）只在限制区域内显示。这意味着代理项可以在列表视图外显示，用户可以看见在列表视图外动态的创建和销毁这些代理项（delegates）。为了防止这个问题，ListView通过设置clip属性为true，来激活裁剪功能。下面的图片展示了这个结果，左边是clip属性设置为false的对比。
 对于用户，ListView（列表视图）是一个滚动区域。它支持惯性滚动，这意味着它可以快速的翻阅内容。默认模式下，它可以在内容最后继续伸展，然后反弹回去，这个信号告诉用户已经到达内容的末尾。
视图末尾的行为是由到boundsBehavior属性的控制的。这是一个枚举值，并且可以配置为默认的Flickable.DragAndOvershootBounds，视图可以通过它的边界线来拖拽和翻阅，配置为Flickable.StopAtBounds，视图将不再可以移动到它的边界线之外。配置为Flickable.DragOverBounds，用户可以将视图拖拽到它的边界线外，但是在边界线上翻阅将无效。
使用snapMode属性可以限制一个视图内元素的停止位置。默认行为下是ListView.NoSnap，允许视图内元素在任何位置停止。将snapMode属性设置为ListView.SnapToItem，视图顶部将会与元素对象的顶部对齐排列。使用ListView.SnapOneItem，当鼠标或者触摸释放时，视图将会停止在第一个可见的元素，这种模式对于浏览页面非常便利。
6.3.1 方向（Orientation） #  默认的链表视图只提供了一个垂直方向的滚动条，但是水平滚动条也是需要的。链表视图的方向由属性orientation控制。它能够被设置为默认值ListView.Vertical或者ListView.Horizontal。下面是一个水平链表视图。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mirrors.cqu.edu.cn/qmlbook/model-view-delegate/dynamic_views/" /><meta property="article:section" content="model-view-delegate" />



<title>Dynamic Views | Qml Book</title>
<link rel="manifest" href="/qmlbook/manifest.json">
<link rel="icon" href="/qmlbook/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/qmlbook/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css" integrity="sha256-l8/aT148n6SaK/jUAfTdwO7Fdsmc3PavvsGRcyAMN9s=" crossorigin="anonymous">
  <script defer src="/qmlbook/flexsearch.min.js"></script>
  <script defer src="/qmlbook/en.search.min.7eaa324ae4aad96718321da9bf7ce2963bf997813e848e1e16bcc0e89048af9b.js" integrity="sha256-fqoySuSq2WcYMh2pv3ziljv5l4E&#43;hI4eFrzA6JBIr5s=" crossorigin="anonymous"></script>

  <script defer src="/qmlbook/sw.min.c5fd65d1492edd0e92acb72a8983e44a68ad14c15883246783ed1d96f25e6858.js" integrity="sha256-xf1l0Uku3Q6SrLcqiYPkSmitFMFYgyRng&#43;0dlvJeaFg=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/qmlbook/"><span>Qml Book</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <h1 id="summary">
  Summary
  <a class="anchor" href="#summary">#</a>
</h1>
<ul>
<li>
  <a href="/qmlbook/README/">Introduction</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/README/">Qt5概述</a>
<ul>
<li>
  <a href="/qmlbook/meet_qt_5/preface/">序</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt5_introduction/">Qt5介绍</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt_building_blocks/">Qt构建模块（Qt Building Blocks）</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt_project/">Qt项目（Qt Project）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/get_start/README/">开始学习（Get Start）</a>
<ul>
<li>
  <a href="/qmlbook/get_start/qt5installing_qt_5_sdk/">安装Qt5软件工具包（Installing Qt 5 SDK）</a></li>
<li>
  <a href="/qmlbook/get_start/hello_world/">你好世界（Hello World）</a></li>
<li>
  <a href="/qmlbook/get_start/application_types/">应用程序类型（Application Types）</a></li>
<li>
  <a href="/qmlbook/get_start/summary/">总结（ Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_creator_ide/README/">Qt Creator集成开发环境（Qt Creator IDE）</a>
<ul>
<li>
  <a href="/qmlbook/qt_creator_ide/the_user_interface/">用户界面（The User Interface）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/qtregistering_your_qt_kit/">注册你的Qt工具箱（Registering your Qt Kit）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/managing_projects/">项目管理（Managing Projects）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/using_the_editor/">使用编辑器（Using the Editor）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/locator/">定位器（Locator）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/debugging/">调试（Debugging）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/shortcuts/">快捷键（Shortcuts）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/quick_starter/README/">QML快速入门（Quick Starter）</a>
<ul>
<li>
  <a href="/qmlbook/quick_starter/qmlqml_syntax/">QML语法（QML Syntax）</a></li>
<li>
  <a href="/qmlbook/quick_starter/basic_elements/">基本元素（Basic Elements）</a></li>
<li>
  <a href="/qmlbook/quick_starter/compontents/">组件（Compontents）</a></li>
<li>
  <a href="/qmlbook/quick_starter/simple_transformations/">简单的转换（Simple Transformations）</a></li>
<li>
  <a href="/qmlbook/quick_starter/positioning_element/">定位元素（Positioning Element）</a></li>
<li>
  <a href="/qmlbook/quick_starter/layout_items/">布局元素（Layout Items）</a></li>
<li>
  <a href="/qmlbook/quick_starter/input_element/">输入元素（Input Element）</a></li>
<li>
  <a href="/qmlbook/quick_starter/advanced_techniques/"> 高级用法（Advanced Techniques）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/fluid_elements/README/">动态元素（Fluid Elements）</a>
<ul>
<li>
  <a href="/qmlbook/fluid_elements/animations/">动画（Animations）</a></li>
<li>
  <a href="/qmlbook/fluid_elements/states_and_transitions/">状态与过渡（States and Transitions）</a></li>
<li>
  <a href="/qmlbook/fluid_elements/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/model-view-delegate/README/">模型-视图-代理（Model-View-Delegate）</a>
<ul>
<li>
  <a href="/qmlbook/model-view-delegate/concept/">概念（Concept）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/basic_model/">基础模型（Basic Model）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/dynamic_views/"class=active>动态视图（Dynamic Views）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/delegate/">代理（Delegate）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/canvas_element/README/">画布元素（Canvas Element）</a>
<ul>
<li>
  <a href="/qmlbook/canvas_element/convenient_api/">便捷的接口（Convenient API）</a></li>
<li>
  <a href="/qmlbook/canvas_element/gradients/">渐变（Gradients）</a></li>
<li>
  <a href="/qmlbook/canvas_element/shadows/">阴影（Shadows）</a></li>
<li>
  <a href="/qmlbook/canvas_element/images/">图片（Images）</a></li>
<li>
  <a href="/qmlbook/canvas_element/transformation/">转换（Transformation）</a></li>
<li>
  <a href="/qmlbook/canvas_element/composition_mode/">组合模式（Composition Mode）</a></li>
<li>
  <a href="/qmlbook/canvas_element/pixels_buffer/">像素缓冲（Pixels Buffer）</a></li>
<li>
  <a href="/qmlbook/canvas_element/canvas_paint/">画布绘制（Canvas Paint）</a></li>
<li>
  <a href="/qmlbook/canvas_element/html5porting_from_html5_canvas/">HTML5画布移植（Porting from HTML5 Canvas）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/particle_simulations/README/">粒子模拟（Particle Simulations）</a>
<ul>
<li>
  <a href="/qmlbook/particle_simulations/concept/">概念（Concept）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/simple_simulation/">简单的模拟（Simple Simulation）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_parameters/">粒子参数（Particle Parameters）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/directed_particle/">粒子方向（Directed Particle）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_painter/">粒子画笔（Particle Painter）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/affecting_particles/">粒子控制（Affecting Particles）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_group/">粒子组（Particle Group）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/shader_effect/README/">着色器效果（Shader Effect）</a>
<ul>
<li>
  <a href="/qmlbook/shader_effect/openglopengl_shader/">OpenGL着色器（OpenGL Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/shader_elements/">着色器元素（Shader Elements）</a></li>
<li>
  <a href="/qmlbook/shader_effect/fragement_shader/">片段着色器（Fragement Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/wave_effect/">波浪效果（Wave Effect）</a></li>
<li>
  <a href="/qmlbook/shader_effect/vertex_shader/">顶点着色器（Vertex Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/curtain_effect/">剧幕效果（Curtain Effect）</a></li>
<li>
  <a href="/qmlbook/shader_effect/qtqt_graphicseffect_library/">Qt图像效果库（Qt GraphicsEffect Library）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/multimedia/README/">多媒体（Multimedia）</a>
<ul>
<li>
  <a href="/qmlbook/multimedia/playing_media/">媒体播放（Playing Media）</a></li>
<li>
  <a href="/qmlbook/multimedia/sounds_effects/">声音效果（Sounds Effects）</a></li>
<li>
  <a href="/qmlbook/multimedia/video_streams/">视频流（Video Streams）</a></li>
<li>
  <a href="/qmlbook/multimedia/capturing_images/">捕捉图像（Capturing Images）</a></li>
<li>
  <a href="/qmlbook/multimedia/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
<li>
  <a href="/qmlbook/multimedia/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/networking/README/">网络（Networking）</a>
<ul>
<li>
  <a href="/qmlbook/networking/httpuiserving_ui_via_http/">通过HTTP服务用户界面（Serving UI via HTTP）</a></li>
<li>
  <a href="/qmlbook/networking/templating/">模板（Templating）</a></li>
<li>
  <a href="/qmlbook/networking/httphttp_requests/">HTTP请求（HTTP Requests）</a></li>
<li>
  <a href="/qmlbook/networking/local_files/">本地文件（Local files）</a></li>
<li>
  <a href="/qmlbook/networking/restrest_api/">REST接口（REST API）</a></li>
<li>
  <a href="/qmlbook/networking/authentication_using_oauth/">使用开放授权登陆验证（Authentication using OAuth）</a></li>
<li>
  <a href="/qmlbook/networking/engine_io/">云服务（Engine IO）</a></li>
<li>
  <a href="/qmlbook/networking/web_sockets/">Web Sockets</a></li>
<li>
  <a href="/qmlbook/networking/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/storage/README/">存储（Storage）</a>
<ul>
<li>
  <a href="/qmlbook/storage/settings/">配置（Settings）</a></li>
<li>
  <a href="/qmlbook/storage/local_storage_-_sql/">本地存储 - SQL（Local Storage - SQL）</a></li>
<li>
  <a href="/qmlbook/storage/other_storage_apis/">其它存储接口（Other Storage APIs）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/README/">动态QML（Dynamic QML）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/loading_components_dynamically/">动态加载组件（Loading Components Dynamically）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/connecting_indirectly/">间接连接（Connecting Indirectly）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/binding_indirectly/">间接绑定（Binding Indirectly）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/creating_and_destroying_objects/">创建与销毁对象（Creating and Destroying Objects）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/dynamically_loading_and_instantiating_items/">动态加载和实例化项（Dynamically Loading and Instantiating Items）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/dynamically_instantiating_items_from_text/">从文本中动态实例化项（Dynamically Instantiating Items from Text）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/managing_dynamically_created_elements/">管理动态创建的元素（Managing Dynamically Created Elements）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/tracking_dynamic_objects/">跟踪动态对象（Tracking Dynamic Objects）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/javascript/README/">JavaScript</a>
<ul>
<li>
  <a href="/qmlbook/javascript/browserhtml_vs_qtquickqml/">浏览器/HTML与QtQuick/QML对比（Browser/HTML vs QtQuick/QML）</a></li>
<li>
  <a href="/qmlbook/javascript/the_language/">JavaScript语法（The Language）</a></li>
<li>
  <a href="/qmlbook/javascript/js_objects/">JS对象（JS Objects）</a></li>
<li>
  <a href="/qmlbook/javascript/creating_a_js_console/">创建JS控制台（Creating a JS Console）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/README/">Qt and C++</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/a_boilerplate_application/">演示程序（A Boilerplate Application）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/the_qobject/">Qt对象（The QObject）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/build_systems/">编译系统（Build Systems）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/qmake/">QMake</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/cmake/">CMake</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/common_qt_classes/">Qt通用类（Common Qt Classes）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/qstring/">QString</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/sequential_containers/">顺序容器（Sequential Containers）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/associative_containers/">组合容器（Associative Containers）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/file_io/">文件IO（File IO）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/models_in_c&#43;&#43;/">C++数据模型（Models in C++）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/a_simple_model/">一个简单的模型（A simple model）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/more_complex_data/">更复杂的数据（More Complex Data）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/dynamic_data/">动态数据（Dynamic Data）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/advanced_techniques/">进阶技巧（Advanced Techniques）</a></li>
</ul>
</li>
</ul>
</li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/README/">C++扩展QML（Extending QML with C++）</a>
<ul>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/understanding_the_qml_run-time/">理解QML运行环境（Understanding the QML Run-time）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/plugin_content/">插件内容（Plugin Content）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/creating_the_plugin/">创建插件（Creating the plugin）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/fileio_implementation/">FileIO实现（FileIO Implementation）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/using_fileio/">使用FileIO（Using FileIO）</a>
<ul>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/the_application_window/">应用程序窗口（The Application Window）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/using_actions/">使用动作（Using Actions）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/formatting_the_table/">格式化表格（Formatting the Table）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/reading_data/">读取数据（Reading Data）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/writing_data/">写入数据（Writing Data）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/finishing_touch/">收尾工作（Finishing Touch）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/other/README/">其它（Other）</a>
<ul>
<li>
  <a href="/qmlbook/other/assets/">示例源码</a></li>
<li>
  <a href="/qmlbook/other/enginsh_to_chinses/">术语英汉对照表</a></li>
<li>
  <a href="/qmlbook/other/book_format/">格式定义</a></li>
<li>
  <a href="/qmlbook/other/collaboration_correction/">协作校正</a></li>
</ul>
</li>
</ul>






  
<ul>
  
  <li>
    <a href="https://github.com/cwc1987/QmlBook-In-Chinese" target="_blank" rel="noopener">
        QmlBook In Chinese
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/qmlbook/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Dynamic Views</strong>

  <label for="toc-control">
    
    <img src="/qmlbook/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#动态视图dynamic-views">动态视图（Dynamic Views）</a>
      <ul>
        <li><a href="#631-方向orientation">6.3.1 方向（Orientation）</a></li>
        <li><a href="#632-键盘导航和高亮">6.3.2 键盘导航和高亮</a></li>
        <li><a href="#633-页眉与页脚header-and-footer">6.3.3 页眉与页脚（Header and Footer）</a></li>
        <li><a href="#634-网格视图the-gridview">6.3.4 网格视图（The GridView）</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="动态视图dynamic-views">
  动态视图（Dynamic Views）
  <a class="anchor" href="#%e5%8a%a8%e6%80%81%e8%a7%86%e5%9b%bedynamic-views">#</a>
</h1>
<p>Repeater元素适合有限的静态数据，但是在真正使用时，模型通常更加复杂和庞大，我们需要一个更加智能的解决方案。QtQuick提供了ListView和GridView元素，这两个都是基于Flickable（可滑动）区域的元素，因此用户可以放入更大的数据。同时，它们限制了同时实例化的代理数量。对于一个大型的模型，这意味着在同一个场景下只会加载有限的元素。</p>
<p>
  <img src="http://qmlbook.org/_images/listview-basic.png" alt="" /></p>
<p>
  <img src="http://qmlbook.org/_images/gridview-basic.png" alt="" /></p>
<p>这两个元素的用法非常类似，我们由ListView开始，然后会描述GridView的模型起点来进行比较。</p>
<p>ListView与Repeater元素像素，它使用了一个model，使用delegate来实例化，并且在两个delegate之间能够设置间隔sapcing。下面的列表显示了怎样设置一个简单的链表。</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 80
    height: 300

    color: &#34;white&#34;

    ListView {
        anchors.fill: parent
        anchors.margins: 20

        clip: true

        model: 100

        delegate: numberDelegate
        spacing: 5
    }

    Component {
        id: numberDelegate

        Rectangle {
            width: 40
            height: 40

            color: &#34;lightGreen&#34;

            Text {
                anchors.centerIn: parent

                font.pixelSize: 10

                text: index
            }
        }
    }
}
</code></pre><p>
  <img src="http://qmlbook.org/_images/listview-basic.png" alt="" /></p>
<p>如果模型包含的数据比屏幕上显示的更多，ListView元素只会显示部分的链表内容。然后由于QtQuick的默认行为导致的问题，列表视图不会限制被显示的代理项（delegates）只在限制区域内显示。这意味着代理项可以在列表视图外显示，用户可以看见在列表视图外动态的创建和销毁这些代理项（delegates）。为了防止这个问题，ListView通过设置clip属性为true，来激活裁剪功能。下面的图片展示了这个结果，左边是clip属性设置为false的对比。</p>
<p>
  <img src="http://qmlbook.org/_images/listview-clip.png" alt="" /></p>
<p>对于用户，ListView（列表视图）是一个滚动区域。它支持惯性滚动，这意味着它可以快速的翻阅内容。默认模式下，它可以在内容最后继续伸展，然后反弹回去，这个信号告诉用户已经到达内容的末尾。</p>
<p>视图末尾的行为是由到boundsBehavior属性的控制的。这是一个枚举值，并且可以配置为默认的Flickable.DragAndOvershootBounds，视图可以通过它的边界线来拖拽和翻阅，配置为Flickable.StopAtBounds，视图将不再可以移动到它的边界线之外。配置为Flickable.DragOverBounds，用户可以将视图拖拽到它的边界线外，但是在边界线上翻阅将无效。</p>
<p>使用snapMode属性可以限制一个视图内元素的停止位置。默认行为下是ListView.NoSnap，允许视图内元素在任何位置停止。将snapMode属性设置为ListView.SnapToItem，视图顶部将会与元素对象的顶部对齐排列。使用ListView.SnapOneItem，当鼠标或者触摸释放时，视图将会停止在第一个可见的元素，这种模式对于浏览页面非常便利。</p>
<h2 id="631-方向orientation">
  6.3.1 方向（Orientation）
  <a class="anchor" href="#631-%e6%96%b9%e5%90%91orientation">#</a>
</h2>
<p>默认的链表视图只提供了一个垂直方向的滚动条，但是水平滚动条也是需要的。链表视图的方向由属性orientation控制。它能够被设置为默认值ListView.Vertical或者ListView.Horizontal。下面是一个水平链表视图。</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 480
    height: 80

    color: &#34;white&#34;

    ListView {
        anchors.fill: parent
        anchors.margins: 20

        clip: true

        model: 100

        orientation: ListView.Horizontal

        delegate: numberDelegate
        spacing: 5
    }

    Component {
        id: numberDelegate

        Rectangle {
            width: 40
            height: 40

            color: &#34;lightGreen&#34;

            Text {
                anchors.centerIn: parent

                font.pixelSize: 10

                text: index
            }
        }
    }
}
</code></pre><p>
  <img src="http://qmlbook.org/_images/listview-horizontal.png" alt="" /></p>
<p>按照上面的设置，水平链表视图默认的元素顺序方向是由左到右。可以通过设置layoutDirection属性来控制元素顺序方向，它可以设置为Qt.LeftToRight或者Qt.RightToLeft。</p>
<h2 id="632-键盘导航和高亮">
  6.3.2 键盘导航和高亮
  <a class="anchor" href="#632-%e9%94%ae%e7%9b%98%e5%af%bc%e8%88%aa%e5%92%8c%e9%ab%98%e4%ba%ae">#</a>
</h2>
<p>当使用基于触摸方式的链表视图时，默认提供的视图已经足够使用。在使用键盘甚至仅仅通过方向键选择一个元素的场景下，需要有标识当前选中元素的机制。在QML中，这被叫做高亮。</p>
<p>视图支持设置一个当前视图中显示代理元素中的高亮代理。它是一个附加的代理元素，这个元素仅仅只实例化一次，并移动到与当前元素相同的位置。</p>
<p>在下面例子的演示中，有两个属性来完成这个工作。首先是focus属性设置为true，它设置链表视图能够获得键盘焦点。然后是highlight属性，指出使用的高亮代理元素。高亮代理元素的x,y与height属性由当前元素指定。如果宽度没有特别指定，当前元素的宽度也可以用于高亮代理元素。</p>
<p>在例子中，ListView.view.width属性被绑定用于高亮元素的宽度。关于代理元素的使绑定属性将在后面的章节讨论，但是最好知道相同的绑定属性也可以用于高亮代理元素。</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 240
    height: 300

    color: &#34;white&#34;

    ListView {
        anchors.fill: parent
        anchors.margins: 20

        clip: true

        model: 100

        delegate: numberDelegate
        spacing: 5

        highlight: highlightComponent
        focus: true
    }

    Component {
        id: highlightComponent

        Rectangle {
            width: ListView.view.width
            color: &#34;lightGreen&#34;
        }
    }

    Component {
        id: numberDelegate

        Item {
            width: 40
            height: 40

            Text {
                anchors.centerIn: parent

                font.pixelSize: 10

                text: index
            }
        }
    }
}
// M1&gt;&gt;
</code></pre><p>
  <img src="http://qmlbook.org/_images/listview-highlight.png" alt="" /></p>
<p>当使用高亮与链表视图（ListView）结合时，一些属性可以用来控制它的行为。highlightRangeMode控制了高亮如何影响视图中当前的显示。默认设置ListView.NoHighLighRange意味着高亮与视图中的元素距离不相关。</p>
<p>ListView.StrictlyEnforceRnage确保了高亮始终可见，如果某个动作尝试将高亮移出当前视图可见范围，当前元素将会自动切换，确保了高亮始终可见。</p>
<p>ListView.ApplyRange，它尝试保持高亮代理始终可见，但是不会强制切换当前元素始终可见。如果在需要的情况下高亮代理允许被移出当前视图。</p>
<p>在默认配置下，视图负责高亮移动到指定位置，移动的速度与大小的改变能够被控制，使用一个速度值或者一个动作持续时间来完成它。这些属性包括highlightMoveSpeed，highlightMoveDuration，highlightResizeSpeed和highlightResizeDuration。默认下速度被设置为每秒400像素，动作持续时间为-1，表明速度和距离控制了动作的持续时间。如果速度与动作持续时间都被设置，动画将会采用速度较快的结果来完成。</p>
<p>为了更加详细的控制高亮的移动，highlightFollowCurrentItem属性设置为false。这意味着视图将不再负责高亮代理的移动。取而代之可以通过一个行为（Bahavior）或者一个动画来控制它。</p>
<p>在下面的例子中，高亮代理的y坐标属性与ListView.view.currentItem.y属性绑定。这确保了高亮始终跟随当前元素。然而，由于我们没有让视图来移动这个高亮代理，我们需要控制这个元素如何移动，通过Behavior on y来完成这个操作，在下面的例子中，移动分为三步完成：淡出，移动，淡入。注意怎样使用SequentialAnimation和PropertyAnimation元素与NumberAnimation结合创建更加复杂的移动效果。</p>
<pre tabindex="0"><code>    Component {
        id: highlightComponent

        Item {
            width: ListView.view.width
            height: ListView.view.currentItem.height

            y: ListView.view.currentItem.y

            Behavior on y {
                SequentialAnimation {
                    PropertyAnimation { target: highlightRectangle; property: &#34;opacity&#34;; to: 0; duration: 200 }
                    NumberAnimation { duration: 1 }
                    PropertyAnimation { target: highlightRectangle; property: &#34;opacity&#34;; to: 1; duration: 200 }
                }
            }

            Rectangle {
                id: highlightRectangle
                anchors.fill: parent
                color: &#34;lightGreen&#34;
            }
        }
    }
</code></pre><h2 id="633-页眉与页脚header-and-footer">
  6.3.3 页眉与页脚（Header and Footer）
  <a class="anchor" href="#633-%e9%a1%b5%e7%9c%89%e4%b8%8e%e9%a1%b5%e8%84%9aheader-and-footer">#</a>
</h2>
<p>这一节是链表视图最后的内容，我们能够向链表视图中插入一个页眉（header）元素和一个页脚（footer）元素。这部分是链表的开始或者结尾处被作为代理元素特殊的区域。对于一个水平链表视图，不会存在页眉或者页脚，但是也有开始和结尾处，这取决于layoutDirection的设置。</p>
<p>下面这个例子展示了如何使用一个页眉和页脚来突出链表的开始与结尾。这些特殊的链表元素也有其它的作用，例如，它们能够保持链表中的按键加载更多的内容。</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 80
    height: 300

    color: &#34;white&#34;

    ListView {
        anchors.fill: parent
        anchors.margins: 20

        clip: true

        model: 4

        delegate: numberDelegate
        spacing: 5

        header: headerComponent
        footer: footerComponent
    }

    Component {
        id: headerComponent

        Rectangle {
            width: 40
            height: 20

            color: &#34;yellow&#34;
        }
    }

    Component {
        id: footerComponent

        Rectangle {
            width: 40
            height: 20

            color: &#34;red&#34;
        }
    }

    Component {
        id: numberDelegate

        Rectangle {
            width: 40
            height: 40

            color: &#34;lightGreen&#34;

            Text {
                anchors.centerIn: parent

                font.pixelSize: 10

                text: index
            }
        }
    }
}
</code></pre><p><strong>注意</strong></p>
<p><strong>页眉与页脚代理元素不遵循链表视图（ListView）的间隔（spacing）属性，它们被直接放在相邻的链表元素之上或之下。这意味着页眉与页脚的间隔必须通过页眉与页脚元素自己设置。</strong></p>
<p>
  <img src="http://qmlbook.org/_images/listview-header-footer.png" alt="" /></p>
<h2 id="634-网格视图the-gridview">
  6.3.4 网格视图（The GridView）
  <a class="anchor" href="#634-%e7%bd%91%e6%a0%bc%e8%a7%86%e5%9b%bethe-gridview">#</a>
</h2>
<p>使用网格视图（GridView）与使用链表视图（ListView）的方式非常类似。真正不同的地方是网格视图（GridView）使用了一个二维数组来存放元素，而链表视图（ListView）是使用的线性链表来存放元素。</p>
<p>
  <img src="http://qmlbook.org/_images/gridview-basic.png" alt="" /></p>
<p>与链表视图（ListView）比较，网格视图（GridView）不依赖于元素间隔和大小来配置元素。它使用单元宽度（cellWidth）与单元高度（cellHeight）属性来控制数组内的二维元素的内容。每个元素从左上角开始依次放入单元格。</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 240
    height: 300

    color: &#34;white&#34;

    GridView {
        anchors.fill: parent
        anchors.margins: 20

        clip: true

        model: 100

        cellWidth: 45
        cellHeight: 45

        delegate: numberDelegate
    }

    Component {
        id: numberDelegate

        Rectangle {
            width: 40
            height: 40

            color: &#34;lightGreen&#34;

            Text {
                anchors.centerIn: parent

                font.pixelSize: 10

                text: index
            }
        }
    }
}
</code></pre><p>一个网格视图（GridView）也包含了页脚与页眉，也可以使用高亮代理并且支持捕捉模式（snap mode）的多种反弹行为。它也可以使用不同的方向（orientations）与定向（directions）来定位。</p>
<p>定向使用flow属性来控制。它可以被设置为GridView.LeftToRight或者GridView.TopToBottom。模型的值从左往右向网格中填充，行添加是从上往下。视图使用一个垂直方向的滚动条。后面添加的元素也是由上到下，由左到右。</p>
<p>此外还有flow属性和layoutDirection属性，能够适配网格从左到右或者从右到左，这依赖于你使用的设置值。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#动态视图dynamic-views">动态视图（Dynamic Views）</a>
      <ul>
        <li><a href="#631-方向orientation">6.3.1 方向（Orientation）</a></li>
        <li><a href="#632-键盘导航和高亮">6.3.2 键盘导航和高亮</a></li>
        <li><a href="#633-页眉与页脚header-and-footer">6.3.3 页眉与页脚（Header and Footer）</a></li>
        <li><a href="#634-网格视图the-gridview">6.3.4 网格视图（The GridView）</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












