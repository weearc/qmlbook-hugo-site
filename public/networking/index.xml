<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Networkings on Qml Book</title>
    <link>https://mirrors.cqu.edu.cn/qmlbook/networking/</link>
    <description>Recent content in Networkings on Qml Book</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://mirrors.cqu.edu.cn/qmlbook/networking/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/authentication_using_oauth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/authentication_using_oauth/</guid>
      <description>使用开放授权登陆验证（Authentication using OAuth） #  OAuth是一个开放协议，允许简单的安全验证，是来自web的典型方法，用于移动和桌面应用程序。使用OAuth对通常的web服务的客户端进行身份验证，例如Google，Facebook和Twitter。
注意
对于自定义的web服务，你也可以使用典型的HTTP身份验证，例如使用XMLHttpRequest的用户名和密码的获取方法（比如xhr.open(verb,url,true,username,password））。
Auth目前不是QML/JS的接口，你需要写一些C++代码并且将身份验证导入到QML/JS中。另一个问题是安全的存储访问密码。
下面这些是我找到的有用的连接：
   http://oauth.net
   http://hueniverse.com/oauth/
   https://github.com/pipacs/o2
   http://www.johanpaul.com/blog/2011/05/oauth2-explained-with-qt-quick/
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/engine_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/engine_io/</guid>
      <description>云服务（Engine IO） #  Engine IO是DIGIA运行的一个web服务。它允许Qt/QML应用程序访问来自Engin.IO的NoSQL存储。这是一个基于云存储对象的Qt/QML接口和一个管理平台。如果你想存储一个QML应用程序的数据到云存储中，它可以提供非常方便的QML/JS的接口。
查看 EnginIO的文档获得更多的帮助。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/httphttp_requests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/httphttp_requests/</guid>
      <description>HTTP请求（HTTP Requests） #  从c++方面来看，Qt中完成http请求通常是使用QNetworkRequest和QNetworkReply，然后使用Qt/C++将响应推送到集成的QML。所以我们尝试使用QtQuick的工具给我们的网络信息尾部封装了小段信息，然后推送这些信息。为此我们使用一个帮助对象来构造http请求，和循环响应。它使用java脚本的XMLHttpRequest对象的格式。
XMLHttpRequest对象允许用户注册一个响应操作函数和一个链接。一个请求能够使用http动作来发送（如get，post，put，delete，等等）。当响应到达时，会调用注册的操作函数。操作函数会被调用多次。每次调用请求的状态都已经改变（例如信息头部已接收，或者响应完成）。
下面是一个简短的例子：
function request() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) { print(&amp;#39;HEADERS_RECEIVED&amp;#39;); } else if(xhr.readyState === XMLHttpRequest.DONE) { print(&amp;#39;DONE&amp;#39;); } } xhr.open(&amp;#34;GET&amp;#34;, &amp;#34;http://example.com&amp;#34;); xhr.send(); } 从一个响应中你可以获取XML格式的数据或者是原始文本。可以遍历XML结果但是通常使用原始文本来匹配JSON格式响应。使用JSON.parse(text）可以JSON文档将转换为JS对象使用。
... } else if(xhr.readyState === XMLHttpRequest.DONE) { var object = JSON.parse(xhr.responseText.toString()); print(JSON.stringify(object, null, 2)); } 在响应操作中，我们访问原始响应文本并且将它转换为一个javascript对象。JSON对象是一个可以使用的JS对象（在javascript中，一个对象可以是对象或者一个数组）。
注意
toString()转换似乎让代码更加稳定。在不使用显式的转换下我有几次都解析错误。不确定是什么问题引起的。
11.3.1 Flickr调用（Flickr Call） #  让我们看看更加真实的例子。一个典型的例子是使用网络相册服务来取得公共订阅中新上传的图片。我们可以使用 http://api.flicker.com/services/feeds/photos_public.gne链接。不幸的是它默认返回XML流格式的数据，在qml中可以很方便的使用XmlListModel来解析。为了达到只关注JSON数据的目的，我们需要在请求中附加一些参数可以得到JSON响应： http://api.flickr.com/services/feeds/photo_public.gne?format=json&amp;amp;nojsoncallback=1。这将会返回一个没有JSON回调的JSON响应。
注意 一个JSON回调将JSON响应包装在一个函数调用中。这是一个HTML编程中的快捷方式，使用脚本标记来创建一个JSON请求。响应将触发本地定义的回调函数。在QML中没有JSON回调的工作机制。
使用curl来查看响应：
curl &amp;#34;http://api.flickr.com/services/feeds/photos_public.gne?format=json&amp;amp;nojsoncallback=1&amp;amp;tags=munich&amp;#34; 响应如下：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/httpuiserving_ui_via_http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/httpuiserving_ui_via_http/</guid>
      <description>通过HTTP服务UI（Serving UI via HTTP） #  通过HTTP加载一个简单的用户界面，我们需要一个web服务器，它为UI文件服务。但是首先我们需要有用户界面，我们在项目里创建一个创建了红色矩形框的main.qml。
// main.qml import QtQuick 2.0 Rectangle { width: 320 height: 320 color: &amp;#39;#ff0000&amp;#39; } 我们加载一段python脚本来提供这个文件：
$ cd &amp;lt;PROJECT&amp;gt; # python -m SimpleHTTPServer 8080 现在我们可以通过 http://localhost:8000/main.qml来访问，你可以像下面这样测试：
$ curl http://localhost:8000/main.qml 或者你可以用浏览器来访问。浏览器无法识别QML，并且无法通过文档来渲染。我们需要创建一个可以浏览QML文档的浏览器。为了渲染文档，我们需要指出qmlscene的位置。不幸的是qmlscene只能读取本地文件。我们为了突破这个限制，我们可以使用自己写的qmlscene或者使用QML动态加载。我们选择动态加载的方式。我们选择一个加载元素来加载远程的文档。
// remote.qml import QtQuick 2.0 Loader { id: root source: &amp;#39;http://localhost:8080/main2.qml&amp;#39; onLoaded: { root.width = item.width root.height = item.height } } 我们现在可以使用qmlscene来加载remote.qml文档。这里仍然有一个小问题。加载器将会调整加载项的大小。我们的qmlscene需要适配大小。可以使用&amp;ndash;resize-to-root选项来运行qmlscene。
$ qmlscene --resize-to-root remote.qml 按照root元素调整大小，告诉qmlscene按照root元素的大小调它的窗口大小。remote现在从本地服务器加载main.qml，并且可以自动调整加载的用户界面。方便且简单。
注意
如果你不想使用一个本地服务器，你可以使用来自GitHub的gist服务。Gist是一个在线剪切板服务，就像PasteBin等等。可以在 https://gist.github.com下使用。我创建了一个简单的gist例子，地址是 https://gist.github.com/jryannel/7983492。这将会返回一个绿色矩形框。由于gist连接提供的是HTML代码，我们需要连接一个/raw来读取原始文件而不是HTML代码。
// remote.qml import QtQuick 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/local_files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/local_files/</guid>
      <description>本地文件（Local files） #  使用XMLHttpRequest也可以加载本地文件（XML/JSON）。例如加载一个本地名为“colors.json”的文件可以这样使用：
xhr.open(&amp;#34;GET&amp;#34;, &amp;#34;colors.json&amp;#34;); 我们使用它读取一个颜色表并且使用表格来显示。从QtQuick这边无法修改文件。为了将源数据存储回去，我们需要一个基于HTTP服务器的REST服务支持或者一个用来访问文件的QtQuick扩展。
import QtQuick 2.0 Rectangle { width: 360 height: 360 color: &amp;#39;#000&amp;#39; GridView { id: view anchors.fill: parent cellWidth: width/4 cellHeight: cellWidth delegate: Rectangle { width: view.cellWidth height: view.cellHeight color: modelData.value } } function request() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) { print(&amp;#39;HEADERS_RECEIVED&amp;#39;) } else if(xhr.readyState === XMLHttpRequest.DONE) { print(&amp;#39;DONE&amp;#39;); var obj = JSON.parse(xhr.responseText.toString()); view.model = obj.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/README/</guid>
      <description>网络（Networking） #  Qt5在C++中有丰富的网络相关的类。例如在http协议层上使用请求回答方式的高级封装类如QNetworkRequest，QNetworkReply，QNetworkAccessManageer。也有在TCP/IP或者UDP协议层封装的低级类如QTcpSocket，QTcpServer和QUdpSocket。还有一些额外的类用来管理代理，网络缓冲和系统网络配置。
这章将不再阐述关于C++网络方面的知识，这章是关于QtQuick与网络的知识。我们应该怎样连接QML/JS用户界面与网络服务，或者如何通过网络服务来为我们用户界面提供服务。已经有很好的教材和示例覆盖了关于Qt/C++的网络编程。然后你只需要阅读这章相关的C++集成来满足你的QtQuick就可以了。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/restrest_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/restrest_api/</guid>
      <description>REST接口（REST API） #  为了使用web服务，我们首先需要创建它。我们使用Flask（http://flask.pocoo.org），一个基于python创建简单的颜色web服务的HTTP服务器应用。你也可以使用其它的web服务器，只要它接收和返回JSON数据。通过web服务来管理一组已经命名的颜色。在这个例子中，管理意味着CRUD（创建-读取-更新-删除）。
在Flask中一个简单的web服务可以写入一个文件。我们使用一个空的服务器.py文件开始，在这个文件中我们创建一些规则并且从额外的JSON文件中加载初始颜色。你可以查看Flask文档获取更多的帮助。
from flask import Flask, jsonify, request import json colors = json.load(file(&amp;#39;colors.json&amp;#39;, &amp;#39;r&amp;#39;)) app = Flask(__name__) # ... service calls go here if __name__ == &amp;#39;__main__&amp;#39;: app.run(debug = True) 当你运行这个脚本后，它会在http://localhost:5000。
我们开始添加我们的CRUD（创建，读取，更新，删除）到我们的web服务。
11.5.1 读取请求（Read Request） #  从web服务读取数据，我们提供GET方法来读取所有的颜色。
@app.route(&amp;#39;/colors&amp;#39;, methods = [&amp;#39;GET&amp;#39;]) def get_colors(): return jsonify( { &amp;#34;colors&amp;#34; : colors }) 这将会返回‘/colors’下的颜色。我们使用curl来创建一个http请求测试。
curl -i -GET http://localhost:5000/colors 这将会返回给我们JSON数据的颜色链表。
11.5.2 读取接口（Read Entry） #  为了通过名字读取颜色，我们提供更加详细的后缀，定位在‘/colors/&amp;lsquo;下。名称是后缀的参数，用来识别一个独立的颜色。
@app.route(&amp;#39;/colors/&amp;lt;name&amp;gt;&amp;#39;, methods = [&amp;#39;GET&amp;#39;]) def get_color(name): for color in colors: if color[&amp;#34;name&amp;#34;] == name: return jsonify( color ) 我们再次使用curl测试，例如获取一个红色的接口。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/summary/</guid>
      <description>总结（Summary） #  这章我们讨论了关于QML的网络应用。请记住Qt已在本地端提供了丰富的网络接口可以在QML中使用。但是这一章的我们是想推动QML的网络运用和如何与云服务集成。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/templating/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/templating/</guid>
      <description>模板（Templating） #  当使用HTML项目时，通常需要使用模板驱动开发。服务器使用模板机制生成代码在服务器端对一个HTML根进行扩展。例如一个照片列表的列表头将使用HTML编码，动态图片链表将会使用模板机制动态生成。通常这也可以使用QML解决，但是仍然有一些问题。
首先，HTML开发者这样做的原因是为了克服HTML后端的限制。在HTML中没有组件模型，动态机制方面不得不使用这些机制或者在客户端边使用javascript编程。很多的JS框架产生（jQuery，dojo，backbone，angular，&amp;hellip;）可以用来解决这个问题，把更多的逻辑问题放在使用网络服务连接的客户端浏览器。客户端使用一个web服务的接口（例如JSON服务，或者XML数据服务）与服务器通信。这也适用于QML。
第二个问题是来自QML的组件缓冲。当QML访问一个组件时，缓冲渲染树（render-tree），并且只加载缓冲版本来渲染。磁盘上的修改版本或者远程的修改在没有重新启动客户端时不会被检测到。为了克服这个问题，我们需要跟踪。我们使用URL后缀来加载链接（例如 http://localhost:8080/main.qml#1234），“#1234”就是后缀标识。HTTP服务器总是为相同的文档服务，但是QML将使用完整的链接来保存这个文档，包括链接标识。每次我们访问的这个链接的标识获得改变，QML缓冲无法获得这个信息。这个后缀标识可以是当前时间的毫秒或者一个随机数。
Loader { source: &amp;#39;http://localhost:8080/main.qml#&amp;#39; + new Date().getTime() } 总之，模板可以实现，但是不推荐，无法完整发挥QML的长处。一个更好的方法是使用web服务提供JSON或者XML数据服务。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mirrors.cqu.edu.cn/qmlbook/networking/web_sockets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mirrors.cqu.edu.cn/qmlbook/networking/web_sockets/</guid>
      <description>Web Sockets #  webSockets不是Qt提供的。将WebSockets加入到Qt/QML中需要花费一些工作。从作者的角度来看WebSockets有巨大的潜力来添加HTTP服务缺少的功能-通知。HTTP给了我们get和post的功能，但是post还不是一个通知。目前客户端轮询服务器来获得应用程序的服务，服务器也需要能通知客户端变化和事件。你可以与QML接口比较：属性，函数，信号。也可以叫做获取/设置/调用和通知。
QML WebSocket插件将会在Qt5中加入。你可以试试来自qt playground的web sockets插件。为了测试，我们使用一个现有的web socket服务实现了echo server。
首先确保你使用的Qt5.2.x。
$ qmake --version ... Using Qt version 5.2.0 ... 然后你需要克隆web socket的代码库，并且编译它。
$ git clone git@gitorious.org:qtplayground/websockets.git $ cd websockets $ qmake $ make $ make install 现在你可以在qml模块中使用web socket。
import Qt.WebSockets 1.0 WebSocket { id: socket } 测试你的web socket，我们使用来自 http://websocket.org的echo server 。
import QtQuick 2.0 import Qt.WebSockets 1.0 Text { width: 480 height: 48 horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter WebSocket { id: socket url: &amp;#34;ws://echo.</description>
    </item>
    
  </channel>
</rss>
