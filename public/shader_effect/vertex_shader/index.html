<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="顶点着色器（Vertex Shader） #  顶点着色器用来操作ShaderEffect提供的顶点。正常情况下，ShaderEffect有4个顶点（左上top-left，右上top-right，左下bottom-left，右下bottom-right）。每个顶点使用vec4类型记录。为了实现顶点着色器的可视化，我们将编写一个吸收的效果。这个效果通常被用来让一个矩形窗口消失为一个点。
 配置场景（Setting up the scene）
首先我们再一次配置场景。
import QtQuick 2.0 Rectangle { width: 480; height: 240 color: &#39;#1e1e1e&#39; Image { id: sourceImage width: 160; height: width source: &#34;assets/lighthouse.jpg&#34; visible: false } Rectangle { width: 160; height: width anchors.centerIn: parent color: &#39;#333333&#39; } ShaderEffect { id: genieEffect width: 160; height: width anchors.centerIn: parent property variant source: sourceImage property bool minimized: false MouseArea { anchors.fill: parent onClicked: genieEffect.minimized = !">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="顶点着色器（Vertex Shader） #  顶点着色器用来操作ShaderEffect提供的顶点。正常情况下，ShaderEffect有4个顶点（左上top-left，右上top-right，左下bottom-left，右下bottom-right）。每个顶点使用vec4类型记录。为了实现顶点着色器的可视化，我们将编写一个吸收的效果。这个效果通常被用来让一个矩形窗口消失为一个点。
 配置场景（Setting up the scene）
首先我们再一次配置场景。
import QtQuick 2.0 Rectangle { width: 480; height: 240 color: &#39;#1e1e1e&#39; Image { id: sourceImage width: 160; height: width source: &#34;assets/lighthouse.jpg&#34; visible: false } Rectangle { width: 160; height: width anchors.centerIn: parent color: &#39;#333333&#39; } ShaderEffect { id: genieEffect width: 160; height: width anchors.centerIn: parent property variant source: sourceImage property bool minimized: false MouseArea { anchors.fill: parent onClicked: genieEffect.minimized = !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mirrors.cqu.edu.cn/qmlbook/shader_effect/vertex_shader/" /><meta property="article:section" content="shader_effect" />



<title>Vertex Shader | Qml Book</title>
<link rel="manifest" href="/qmlbook/manifest.json">
<link rel="icon" href="/qmlbook/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/qmlbook/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css" integrity="sha256-l8/aT148n6SaK/jUAfTdwO7Fdsmc3PavvsGRcyAMN9s=" crossorigin="anonymous">
  <script defer src="/qmlbook/flexsearch.min.js"></script>
  <script defer src="/qmlbook/en.search.min.7eaa324ae4aad96718321da9bf7ce2963bf997813e848e1e16bcc0e89048af9b.js" integrity="sha256-fqoySuSq2WcYMh2pv3ziljv5l4E&#43;hI4eFrzA6JBIr5s=" crossorigin="anonymous"></script>

  <script defer src="/qmlbook/sw.min.c5fd65d1492edd0e92acb72a8983e44a68ad14c15883246783ed1d96f25e6858.js" integrity="sha256-xf1l0Uku3Q6SrLcqiYPkSmitFMFYgyRng&#43;0dlvJeaFg=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/qmlbook/"><span>Qml Book</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <h1 id="summary">
  Summary
  <a class="anchor" href="#summary">#</a>
</h1>
<ul>
<li>
  <a href="/qmlbook/README/">Introduction</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/README/">Qt5概述</a>
<ul>
<li>
  <a href="/qmlbook/meet_qt_5/preface/">序</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt5_introduction/">Qt5介绍</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt_building_blocks/">Qt构建模块（Qt Building Blocks）</a></li>
<li>
  <a href="/qmlbook/meet_qt_5/qt_project/">Qt项目（Qt Project）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/get_start/README/">开始学习（Get Start）</a>
<ul>
<li>
  <a href="/qmlbook/get_start/qt5installing_qt_5_sdk/">安装Qt5软件工具包（Installing Qt 5 SDK）</a></li>
<li>
  <a href="/qmlbook/get_start/hello_world/">你好世界（Hello World）</a></li>
<li>
  <a href="/qmlbook/get_start/application_types/">应用程序类型（Application Types）</a></li>
<li>
  <a href="/qmlbook/get_start/summary/">总结（ Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_creator_ide/README/">Qt Creator集成开发环境（Qt Creator IDE）</a>
<ul>
<li>
  <a href="/qmlbook/qt_creator_ide/the_user_interface/">用户界面（The User Interface）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/qtregistering_your_qt_kit/">注册你的Qt工具箱（Registering your Qt Kit）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/managing_projects/">项目管理（Managing Projects）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/using_the_editor/">使用编辑器（Using the Editor）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/locator/">定位器（Locator）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/debugging/">调试（Debugging）</a></li>
<li>
  <a href="/qmlbook/qt_creator_ide/shortcuts/">快捷键（Shortcuts）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/quick_starter/README/">QML快速入门（Quick Starter）</a>
<ul>
<li>
  <a href="/qmlbook/quick_starter/qmlqml_syntax/">QML语法（QML Syntax）</a></li>
<li>
  <a href="/qmlbook/quick_starter/basic_elements/">基本元素（Basic Elements）</a></li>
<li>
  <a href="/qmlbook/quick_starter/compontents/">组件（Compontents）</a></li>
<li>
  <a href="/qmlbook/quick_starter/simple_transformations/">简单的转换（Simple Transformations）</a></li>
<li>
  <a href="/qmlbook/quick_starter/positioning_element/">定位元素（Positioning Element）</a></li>
<li>
  <a href="/qmlbook/quick_starter/layout_items/">布局元素（Layout Items）</a></li>
<li>
  <a href="/qmlbook/quick_starter/input_element/">输入元素（Input Element）</a></li>
<li>
  <a href="/qmlbook/quick_starter/advanced_techniques/"> 高级用法（Advanced Techniques）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/fluid_elements/README/">动态元素（Fluid Elements）</a>
<ul>
<li>
  <a href="/qmlbook/fluid_elements/animations/">动画（Animations）</a></li>
<li>
  <a href="/qmlbook/fluid_elements/states_and_transitions/">状态与过渡（States and Transitions）</a></li>
<li>
  <a href="/qmlbook/fluid_elements/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/model-view-delegate/README/">模型-视图-代理（Model-View-Delegate）</a>
<ul>
<li>
  <a href="/qmlbook/model-view-delegate/concept/">概念（Concept）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/basic_model/">基础模型（Basic Model）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/dynamic_views/">动态视图（Dynamic Views）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/delegate/">代理（Delegate）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
<li>
  <a href="/qmlbook/model-view-delegate/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/canvas_element/README/">画布元素（Canvas Element）</a>
<ul>
<li>
  <a href="/qmlbook/canvas_element/convenient_api/">便捷的接口（Convenient API）</a></li>
<li>
  <a href="/qmlbook/canvas_element/gradients/">渐变（Gradients）</a></li>
<li>
  <a href="/qmlbook/canvas_element/shadows/">阴影（Shadows）</a></li>
<li>
  <a href="/qmlbook/canvas_element/images/">图片（Images）</a></li>
<li>
  <a href="/qmlbook/canvas_element/transformation/">转换（Transformation）</a></li>
<li>
  <a href="/qmlbook/canvas_element/composition_mode/">组合模式（Composition Mode）</a></li>
<li>
  <a href="/qmlbook/canvas_element/pixels_buffer/">像素缓冲（Pixels Buffer）</a></li>
<li>
  <a href="/qmlbook/canvas_element/canvas_paint/">画布绘制（Canvas Paint）</a></li>
<li>
  <a href="/qmlbook/canvas_element/html5porting_from_html5_canvas/">HTML5画布移植（Porting from HTML5 Canvas）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/particle_simulations/README/">粒子模拟（Particle Simulations）</a>
<ul>
<li>
  <a href="/qmlbook/particle_simulations/concept/">概念（Concept）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/simple_simulation/">简单的模拟（Simple Simulation）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_parameters/">粒子参数（Particle Parameters）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/directed_particle/">粒子方向（Directed Particle）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_painter/">粒子画笔（Particle Painter）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/affecting_particles/">粒子控制（Affecting Particles）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/particle_group/">粒子组（Particle Group）</a></li>
<li>
  <a href="/qmlbook/particle_simulations/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/shader_effect/README/">着色器效果（Shader Effect）</a>
<ul>
<li>
  <a href="/qmlbook/shader_effect/openglopengl_shader/">OpenGL着色器（OpenGL Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/shader_elements/">着色器元素（Shader Elements）</a></li>
<li>
  <a href="/qmlbook/shader_effect/fragement_shader/">片段着色器（Fragement Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/wave_effect/">波浪效果（Wave Effect）</a></li>
<li>
  <a href="/qmlbook/shader_effect/vertex_shader/"class=active>顶点着色器（Vertex Shader）</a></li>
<li>
  <a href="/qmlbook/shader_effect/curtain_effect/">剧幕效果（Curtain Effect）</a></li>
<li>
  <a href="/qmlbook/shader_effect/qtqt_graphicseffect_library/">Qt图像效果库（Qt GraphicsEffect Library）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/multimedia/README/">多媒体（Multimedia）</a>
<ul>
<li>
  <a href="/qmlbook/multimedia/playing_media/">媒体播放（Playing Media）</a></li>
<li>
  <a href="/qmlbook/multimedia/sounds_effects/">声音效果（Sounds Effects）</a></li>
<li>
  <a href="/qmlbook/multimedia/video_streams/">视频流（Video Streams）</a></li>
<li>
  <a href="/qmlbook/multimedia/capturing_images/">捕捉图像（Capturing Images）</a></li>
<li>
  <a href="/qmlbook/multimedia/advanced_techniques/">高级用法（Advanced Techniques）</a></li>
<li>
  <a href="/qmlbook/multimedia/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/networking/README/">网络（Networking）</a>
<ul>
<li>
  <a href="/qmlbook/networking/httpuiserving_ui_via_http/">通过HTTP服务用户界面（Serving UI via HTTP）</a></li>
<li>
  <a href="/qmlbook/networking/templating/">模板（Templating）</a></li>
<li>
  <a href="/qmlbook/networking/httphttp_requests/">HTTP请求（HTTP Requests）</a></li>
<li>
  <a href="/qmlbook/networking/local_files/">本地文件（Local files）</a></li>
<li>
  <a href="/qmlbook/networking/restrest_api/">REST接口（REST API）</a></li>
<li>
  <a href="/qmlbook/networking/authentication_using_oauth/">使用开放授权登陆验证（Authentication using OAuth）</a></li>
<li>
  <a href="/qmlbook/networking/engine_io/">云服务（Engine IO）</a></li>
<li>
  <a href="/qmlbook/networking/web_sockets/">Web Sockets</a></li>
<li>
  <a href="/qmlbook/networking/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/storage/README/">存储（Storage）</a>
<ul>
<li>
  <a href="/qmlbook/storage/settings/">配置（Settings）</a></li>
<li>
  <a href="/qmlbook/storage/local_storage_-_sql/">本地存储 - SQL（Local Storage - SQL）</a></li>
<li>
  <a href="/qmlbook/storage/other_storage_apis/">其它存储接口（Other Storage APIs）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/README/">动态QML（Dynamic QML）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/loading_components_dynamically/">动态加载组件（Loading Components Dynamically）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/connecting_indirectly/">间接连接（Connecting Indirectly）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/binding_indirectly/">间接绑定（Binding Indirectly）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/creating_and_destroying_objects/">创建与销毁对象（Creating and Destroying Objects）</a>
<ul>
<li>
  <a href="/qmlbook/dynamic_qml/dynamically_loading_and_instantiating_items/">动态加载和实例化项（Dynamically Loading and Instantiating Items）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/dynamically_instantiating_items_from_text/">从文本中动态实例化项（Dynamically Instantiating Items from Text）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/managing_dynamically_created_elements/">管理动态创建的元素（Managing Dynamically Created Elements）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/dynamic_qml/tracking_dynamic_objects/">跟踪动态对象（Tracking Dynamic Objects）</a></li>
<li>
  <a href="/qmlbook/dynamic_qml/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/javascript/README/">JavaScript</a>
<ul>
<li>
  <a href="/qmlbook/javascript/browserhtml_vs_qtquickqml/">浏览器/HTML与QtQuick/QML对比（Browser/HTML vs QtQuick/QML）</a></li>
<li>
  <a href="/qmlbook/javascript/the_language/">JavaScript语法（The Language）</a></li>
<li>
  <a href="/qmlbook/javascript/js_objects/">JS对象（JS Objects）</a></li>
<li>
  <a href="/qmlbook/javascript/creating_a_js_console/">创建JS控制台（Creating a JS Console）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/README/">Qt and C++</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/a_boilerplate_application/">演示程序（A Boilerplate Application）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/the_qobject/">Qt对象（The QObject）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/build_systems/">编译系统（Build Systems）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/qmake/">QMake</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/cmake/">CMake</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/common_qt_classes/">Qt通用类（Common Qt Classes）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/qstring/">QString</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/sequential_containers/">顺序容器（Sequential Containers）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/associative_containers/">组合容器（Associative Containers）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/file_io/">文件IO（File IO）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/models_in_c&#43;&#43;/">C++数据模型（Models in C++）</a>
<ul>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/a_simple_model/">一个简单的模型（A simple model）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/more_complex_data/">更复杂的数据（More Complex Data）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/dynamic_data/">动态数据（Dynamic Data）</a></li>
<li>
  <a href="/qmlbook/qt_and_c&#43;&#43;/advanced_techniques/">进阶技巧（Advanced Techniques）</a></li>
</ul>
</li>
</ul>
</li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/README/">C++扩展QML（Extending QML with C++）</a>
<ul>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/understanding_the_qml_run-time/">理解QML运行环境（Understanding the QML Run-time）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/plugin_content/">插件内容（Plugin Content）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/creating_the_plugin/">创建插件（Creating the plugin）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/fileio_implementation/">FileIO实现（FileIO Implementation）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/using_fileio/">使用FileIO（Using FileIO）</a>
<ul>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/the_application_window/">应用程序窗口（The Application Window）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/using_actions/">使用动作（Using Actions）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/formatting_the_table/">格式化表格（Formatting the Table）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/reading_data/">读取数据（Reading Data）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/writing_data/">写入数据（Writing Data）</a></li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/finishing_touch/">收尾工作（Finishing Touch）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/extending_qml_with_c&#43;&#43;/summary/">总结（Summary）</a></li>
</ul>
</li>
<li>
  <a href="/qmlbook/other/README/">其它（Other）</a>
<ul>
<li>
  <a href="/qmlbook/other/assets/">示例源码</a></li>
<li>
  <a href="/qmlbook/other/enginsh_to_chinses/">术语英汉对照表</a></li>
<li>
  <a href="/qmlbook/other/book_format/">格式定义</a></li>
<li>
  <a href="/qmlbook/other/collaboration_correction/">协作校正</a></li>
</ul>
</li>
</ul>






  
<ul>
  
  <li>
    <a href="https://github.com/cwc1987/QmlBook-In-Chinese" target="_blank" rel="noopener">
        QmlBook In Chinese
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/qmlbook/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Vertex Shader</strong>

  <label for="toc-control">
    
    <img src="/qmlbook/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#顶点着色器vertex-shader">顶点着色器（Vertex Shader）</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="顶点着色器vertex-shader">
  顶点着色器（Vertex Shader）
  <a class="anchor" href="#%e9%a1%b6%e7%82%b9%e7%9d%80%e8%89%b2%e5%99%a8vertex-shader">#</a>
</h1>
<p>顶点着色器用来操作ShaderEffect提供的顶点。正常情况下，ShaderEffect有4个顶点（左上top-left，右上top-right，左下bottom-left，右下bottom-right）。每个顶点使用vec4类型记录。为了实现顶点着色器的可视化，我们将编写一个吸收的效果。这个效果通常被用来让一个矩形窗口消失为一个点。</p>
<p>
  <img src="http://qmlbook.org/_images/genieeffect.png" alt="" /></p>
<p><strong>配置场景（Setting up the scene）</strong></p>
<p>首先我们再一次配置场景。</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 480; height: 240
    color: &#39;#1e1e1e&#39;

    Image {
        id: sourceImage
        width: 160; height: width
        source: &#34;assets/lighthouse.jpg&#34;
        visible: false
    }
    Rectangle {
        width: 160; height: width
        anchors.centerIn: parent
        color: &#39;#333333&#39;
    }
    ShaderEffect {
        id: genieEffect
        width: 160; height: width
        anchors.centerIn: parent
        property variant source: sourceImage
        property bool minimized: false
        MouseArea {
            anchors.fill: parent
            onClicked: genieEffect.minimized = !genieEffect.minimized
        }
    }
}
</code></pre><p>这个场景使用了一个黑色背景，并且提供了一个使用图片作为资源纹理的ShaderEffect。使用image元素的原图片是不可见的，只是给我们的吸收效果提供资源。此外我们在ShaderEffect的位置添加了一个同样大小的黑色矩形框，这样我们可以更加明确的知道我们需要点击哪里来重置效果。</p>
<p>
  <img src="http://qmlbook.org/_images/geniescene.png" alt="" /></p>
<p>点击图片将会触发效果，MouseArea覆盖了ShaderEffect。在onClicked操作中，我们绑定了自定义的布尔变量属性minimized。我们稍后使用这个属性来触发效果。</p>
<p><strong>最小化与正常化（Minimize and normalize）</strong></p>
<p>在我们配置好场景后，我们定义一个real类型的属性，叫做minimize，这个属性包含了我们当前最小化的值。这个值在0.0到1.0之间，由一个连续的动画来控制它。</p>
<pre tabindex="0"><code>        property real minimize: 0.0

        SequentialAnimation on minimize {
            id: animMinimize
            running: genieEffect.minimized
            PauseAnimation { duration: 300 }
            NumberAnimation { to: 1; duration: 700; easing.type: Easing.InOutSine }
            PauseAnimation { duration: 1000 }
        }

        SequentialAnimation on minimize {
            id: animNormalize
            running: !genieEffect.minimized
            NumberAnimation { to: 0; duration: 700; easing.type: Easing.InOutSine }
            PauseAnimation { duration: 1300 }
        }
</code></pre><p>这个动画绑定了由minimized属性触发。现在我们已经配置好我们的环境，最后让我们看看顶点着色器的代码。</p>
<pre tabindex="0"><code>        vertexShader: &#34;
            uniform highp mat4 qt_Matrix;
            attribute highp vec4 qt_Vertex;
            attribute highp vec2 qt_MultiTexCoord0;
            varying highp vec2 qt_TexCoord0;
            uniform highp float minimize;
            uniform highp float width;
            uniform highp float height;
            void main() {
                qt_TexCoord0 = qt_MultiTexCoord0;
                highp vec4 pos = qt_Vertex;
                pos.y = mix(qt_Vertex.y, height, minimize);
                pos.x = mix(qt_Vertex.x, width, minimize);
                gl_Position = qt_Matrix * pos;
            }&#34;
</code></pre><p>顶点着色器被每个顶点调用，在我们这个例子中，一共调用了四次。默认下提供qt已定义的参数，如qt_Matrix，qt_Vertex，qt_MultiTexCoord0，qt_TexCoord0。我们在之前已经讨论过这些变量。此外我们从ShaderEffect中链接minimize，width与height的值到我们的顶点着色器代码中。在main函数中，我们将当前纹理值保存在qt_TexCoord()中，让它在片段着色器中可用。现在我们拷贝当前位置，并修改顶点的x,y的位置。</p>
<pre tabindex="0"><code>highp vec4 pos = qt_Vertex;
pos.y = mix(qt_Vertex.y, height, minimize);
pos.x = mix(qt_Vertex.x, width, minimize);
</code></pre><p>mix(&hellip;)函数提供了一种在两个参数之间（0.0到1.0）的线性插值的算法。在我们的例子中，在当前y值与高度值之间基于minimize的值插值获得y值，x的值获取类似。记住minimize的值是由我们的连续动画控制，并且在0.0到1.0之间（反之亦然）。</p>
<p>
  <img src="http://qmlbook.org/_images/genieminimize.png" alt="" /></p>
<p>这个结果的效果不是真正吸收效果，但是已经能朝着这个目标完成了一大步。</p>
<p><strong>基础弯曲（Primitive Bending）</strong></p>
<p>我们已经完成了最小化我们的坐标。现在我们想要修改一下对x值的操作，让它依赖当前的y值。这个改变很简单。y值计算在前。x值的插值基于当前顶点的y坐标。</p>
<pre tabindex="0"><code>highp float t = pos.y / height;
pos.x = mix(qt_Vertex.x, width, t * minimize);
</code></pre><p>这个结果造成当y值比较大时，x的位置更靠近width的值。也就是说上面2个顶点根本不受影响，它们的y值始终为0，下面两个顶点的x坐标值更靠近width的值，它们最后转向同一个x值。</p>
<p>
  <img src="http://qmlbook.org/_images/geniebending.png" alt="" /></p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 480; height: 240
    color: &#39;#1e1e1e&#39;

    Image {
        id: sourceImage
        width: 160; height: width
        source: &#34;assets/lighthouse.jpg&#34;
        visible: false
    }
    Rectangle {
        width: 160; height: width
        anchors.centerIn: parent
        color: &#39;#333333&#39;
    }
    ShaderEffect {
        id: genieEffect
        width: 160; height: width
        anchors.centerIn: parent
        property variant source: sourceImage
        property real minimize: 0.0
        property bool minimized: false


        SequentialAnimation on minimize {
            id: animMinimize
            running: genieEffect.minimized
            PauseAnimation { duration: 300 }
            NumberAnimation { to: 1; duration: 700; easing.type: Easing.InOutSine }
            PauseAnimation { duration: 1000 }
        }

        SequentialAnimation on minimize {
            id: animNormalize
            running: !genieEffect.minimized
            NumberAnimation { to: 0; duration: 700; easing.type: Easing.InOutSine }
            PauseAnimation { duration: 1300 }
        }


        vertexShader: &#34;
            uniform highp mat4 qt_Matrix;
            uniform highp float minimize;
            uniform highp float height;
            uniform highp float width;
            attribute highp vec4 qt_Vertex;
            attribute highp vec2 qt_MultiTexCoord0;
            varying highp vec2 qt_TexCoord0;
            void main() {
                qt_TexCoord0 = qt_MultiTexCoord0;
                // M1&gt;&gt;
                highp vec4 pos = qt_Vertex;
                pos.y = mix(qt_Vertex.y, height, minimize);
                highp float t = pos.y / height;
                pos.x = mix(qt_Vertex.x, width, t * minimize);
                gl_Position = qt_Matrix * pos;
</code></pre><p><strong>更好的弯曲（Better Bending）</strong></p>
<p>现在简单的弯曲并不能真正的满足我们的要求，我们将添加几个部件来提升它的效果。首先我们增加动画，支持一个自定义的弯曲属性。这是非常必要的，由于弯曲立即发生，y值的最小化需要被推迟。两个动画在同一持续时间计算总和（300+700+100与700+1300）。</p>
<pre tabindex="0"><code>        property real bend: 0.0
        property bool minimized: false


        // change to parallel animation
        ParallelAnimation {
            id: animMinimize
            running: genieEffect.minimized
            SequentialAnimation {
                PauseAnimation { duration: 300 }
                NumberAnimation {
                    target: genieEffect; property: &#39;minimize&#39;;
                    to: 1; duration: 700;
                    easing.type: Easing.InOutSine
                }
                PauseAnimation { duration: 1000 }
            }
            // adding bend animation
            SequentialAnimation {
                NumberAnimation {
                    target: genieEffect; property: &#39;bend&#39;
                    to: 1; duration: 700;
                    easing.type: Easing.InOutSine }
                PauseAnimation { duration: 1300 }
            }
        }
</code></pre><p>此外，为了使弯曲更加平滑，不再使用y值影响x值的弯曲函数，pos.x现在依赖新的弯曲属性动画：</p>
<pre tabindex="0"><code>highp float t = pos.y / height;
t = (3.0 - 2.0 * t) * t * t;
pos.x = mix(qt_Vertex.x, width, t * bend);
</code></pre><p>弯曲从0.0平滑开始，逐渐加快，在1.0时逐渐平滑。下面是这个函数在指定范围内的曲线图。对于我们，只需要关注0到1的区间。</p>
<p>
  <img src="http://qmlbook.org/_images/curve.png" alt="" /></p>
<p>想要获得最大化的视觉改变，需要增加我们的顶点数量。可以使用网眼（mesh）来增加顶点：</p>
<pre tabindex="0"><code>mesh: GridMesh { resolution: Qt.size(16, 16) }
</code></pre><p>现在ShaderEffect被分布为16x16顶点的网格，替换了之前2x2的顶点。这样顶点之间的插值将会看起来更加平滑。</p>
<p>
  <img src="http://qmlbook.org/_images/geniesmoothbending.png" alt="" /></p>
<p>你可以看见曲线的变化，在最后让弯曲变得非常平滑。这让弯曲有了更加强大的效果。</p>
<p><strong>侧面收缩（Choosing Sides）</strong></p>
<p>最后一个增强，我们希望能够收缩边界。边界朝着吸收的点消失。直到现在它总是在朝着width值的点消失。添加一个边界属性，我们能够修改这个点在0到width之间。</p>
<pre tabindex="0"><code>ShaderEffect {
    ...
    property real side: 0.5

    vertexShader: &#34;
        ...
        uniform highp float side;
        ...
        pos.x = mix(qt_Vertex.x, side * width, t * bend);
    &#34;
}
</code></pre><p>
  <img src="http://qmlbook.org/_images/geniehalfside.png" alt="" /></p>
<p><strong>包装（Packing）</strong></p>
<p>最后将我们的效果包装起来。将我们吸收效果的代码提取到一个叫做GenieEffect的自定义组件中。它使用ShaderEffect作为根元素。移除掉MouseArea，这不应该放在组件中。绑定minimized属性来触发效果。</p>
<pre tabindex="0"><code>import QtQuick 2.0

ShaderEffect {
    id: genieEffect
    width: 160; height: width
    anchors.centerIn: parent
    property variant source
    mesh: GridMesh { resolution: Qt.size(10, 10) }
    property real minimize: 0.0
    property real bend: 0.0
    property bool minimized: false
    property real side: 1.0


    ParallelAnimation {
        id: animMinimize
        running: genieEffect.minimized
        SequentialAnimation {
            PauseAnimation { duration: 300 }
            NumberAnimation {
                target: genieEffect; property: &#39;minimize&#39;;
                to: 1; duration: 700;
                easing.type: Easing.InOutSine
            }
            PauseAnimation { duration: 1000 }
        }
        SequentialAnimation {
            NumberAnimation {
                target: genieEffect; property: &#39;bend&#39;
                to: 1; duration: 700;
                easing.type: Easing.InOutSine }
            PauseAnimation { duration: 1300 }
        }
    }

    ParallelAnimation {
        id: animNormalize
        running: !genieEffect.minimized
        SequentialAnimation {
            NumberAnimation {
                target: genieEffect; property: &#39;minimize&#39;;
                to: 0; duration: 700;
                easing.type: Easing.InOutSine
            }
            PauseAnimation { duration: 1300 }
        }
        SequentialAnimation {
            PauseAnimation { duration: 300 }
            NumberAnimation {
                target: genieEffect; property: &#39;bend&#39;
                to: 0; duration: 700;
                easing.type: Easing.InOutSine }
            PauseAnimation { duration: 1000 }
        }
    }

    vertexShader: &#34;
        uniform highp mat4 qt_Matrix;
        attribute highp vec4 qt_Vertex;
        attribute highp vec2 qt_MultiTexCoord0;
        uniform highp float height;
        uniform highp float width;
        uniform highp float minimize;
        uniform highp float bend;
        uniform highp float side;
        varying highp vec2 qt_TexCoord0;
        void main() {
            qt_TexCoord0 = qt_MultiTexCoord0;
            highp vec4 pos = qt_Vertex;
            pos.y = mix(qt_Vertex.y, height, minimize);
            highp float t = pos.y / height;
            t = (3.0 - 2.0 * t) * t * t;
            pos.x = mix(qt_Vertex.x, side * width, t * bend);
            gl_Position = qt_Matrix * pos;
        }&#34;
}
</code></pre><p>你现在可以像这样简单的使用这个效果：</p>
<pre tabindex="0"><code>import QtQuick 2.0

Rectangle {
    width: 480; height: 240
    color: &#39;#1e1e1e&#39;

    GenieEffect {
        source: Image { source: &#39;assets/lighthouse.jpg&#39; }
        MouseArea {
            anchors.fill: parent
            onClicked: parent.minimized = !parent.minimized
        }
    }
}
</code></pre><p>我们简化了代码，移除了背景矩形框，直接使用图片完成效果，替换了在一个单独的图像元素中加载它。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#顶点着色器vertex-shader">顶点着色器（Vertex Shader）</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












